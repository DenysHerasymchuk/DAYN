{
    "root": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN",
    "generated_at": "2026-01-25T23:40:27.579834+00:00",
    "structure": {
        "type": "directory",
        "name": "DAYN",
        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN",
        "children": [
            {
                "type": "directory",
                "name": ".claude",
                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\.claude",
                "children": [
                    {
                        "type": "file",
                        "name": "settings.local.json",
                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\.claude\\settings.local.json",
                        "size_bytes": 0,
                        "content": ""
                    }
                ]
            },
            {
                "type": "file",
                "name": ".env.example",
                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\.env.example",
                "size_bytes": 108,
                "content": "BOT_TOKEN=your_telegram_bot_token_here\\npremium=false\\nMAX_FILE_SIZE=52428800\\nTEMP_DIR=temp\\nLOG_LEVEL=INFO"
            },
            {
                "type": "file",
                "name": ".gitignore",
                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\.gitignore",
                "size_bytes": 4895,
                "content": "# Byte-compiled / optimized / DLL files\\n__pycache__/\\n*.py[codz]\\n*$py.class\\n\\n# C extensions\\n*.so\\n\\n# Distribution / packaging\\n.Python\\nbuild/\\ndevelop-eggs/\\ndist/\\ndownloads/\\neggs/\\n.eggs/\\nlib/\\nlib64/\\nparts/\\nsdist/\\nvar/\\nwheels/\\nshare/python-wheels/\\n*.egg-info/\\n.installed.cfg\\n*.egg\\nMANIFEST\\n\\n# PyInstaller\\n#  Usually these files are written by a python script from a template\\n#  before PyInstaller builds the exe, so as to inject date/other infos into it.\\n*.manifest\\n*.spec\\n\\n# Installer logs\\npip-log.txt\\npip-delete-this-directory.txt\\n\\n# Unit test / coverage reports\\nhtmlcov/\\n.tox/\\n.nox/\\n.coverage\\n.coverage.*\\n.cache\\nnosetests.xml\\ncoverage.xml\\n*.cover\\n*.py.cover\\n.hypothesis/\\n.pytest_cache/\\ncover/\\n\\n# Translations\\n*.mo\\n*.pot\\n\\n# Django stuff:\\n*.log\\nlocal_settings.py\\ndb.sqlite3\\ndb.sqlite3-journal\\n\\n# Flask stuff:\\ninstance/\\n.webassets-cache\\n\\n# Scrapy stuff:\\n.scrapy\\n\\n# Sphinx documentation\\ndocs/_build/\\n\\n# PyBuilder\\n.pybuilder/\\ntarget/\\n\\n# Jupyter Notebook\\n.ipynb_checkpoints\\n\\n# IPython\\nprofile_default/\\nipython_config.py\\n\\n# pyenv\\n#   For a library or package, you might want to ignore these files since the code is\\n#   intended to run in multiple environments; otherwise, check them in:\\n# .python-version\\n\\n# pipenv\\n#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.\\n#   However, in case of collaboration, if having platform-specific dependencies or dependencies\\n#   having no cross-platform support, pipenv may install dependencies that don't work, or not\\n#   install all needed dependencies.\\n#Pipfile.lock\\n\\n# UV\\n#   Similar to Pipfile.lock, it is generally recommended to include uv.lock in version control.\\n#   This is especially recommended for binary packages to ensure reproducibility, and is more\\n#   commonly ignored for libraries.\\n#uv.lock\\n\\n# poetry\\n#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.\\n#   This is especially recommended for binary packages to ensure reproducibility, and is more\\n#   commonly ignored for libraries.\\n#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control\\n#poetry.lock\\n#poetry.toml\\n\\n# pdm\\n#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.\\n#   pdm recommends including project-wide configuration in pdm.toml, but excluding .pdm-python.\\n#   https://pdm-project.org/en/latest/usage/project/#working-with-version-control\\n#pdm.lock\\n#pdm.toml\\n.pdm-python\\n.pdm-build/\\n\\n# pixi\\n#   Similar to Pipfile.lock, it is generally recommended to include pixi.lock in version control.\\n#pixi.lock\\n#   Pixi creates a virtual environment in the .pixi directory, just like venv module creates one\\n#   in the .venv directory. It is recommended not to include this directory in version control.\\n.pixi\\n\\n# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm\\n__pypackages__/\\n\\n# Celery stuff\\ncelerybeat-schedule\\ncelerybeat.pid\\n\\n# SageMath parsed files\\n*.sage.py\\n\\n# Environments\\n.env\\n.envrc\\n.venv\\nenv/\\nvenv/\\nENV/\\nenv.bak/\\nvenv.bak/\\n\\n# Spyder project settings\\n.spyderproject\\n.spyproject\\n\\n# Rope project settings\\n.ropeproject\\n\\n# mkdocs documentation\\n/site\\n\\n# mypy\\n.mypy_cache/\\n.dmypy.json\\ndmypy.json\\n\\n# Pyre type checker\\n.pyre/\\n\\n# pytype static type analyzer\\n.pytype/\\n\\n# Cython debug symbols\\ncython_debug/\\n\\n# PyCharm\\n#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can\\n#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore\\n#  and can be added to the global gitignore or merged into this file.  For a more nuclear\\n#  option (not recommended) you can uncomment the following to ignore the entire idea folder.\\n#.idea/\\n\\n# Abstra\\n# Abstra is an AI-powered process automation framework.\\n# Ignore directories containing user credentials, local state, and settings.\\n# Learn more at https://abstra.io/docs\\n.abstra/\\n\\n# Visual Studio Code\\n#  Visual Studio Code specific template is maintained in a separate VisualStudioCode.gitignore \\n#  that can be found at https://github.com/github/gitignore/blob/main/Global/VisualStudioCode.gitignore\\n#  and can be added to the global gitignore or merged into this file. However, if you prefer, \\n#  you could uncomment the following to ignore the entire vscode folder\\n# .vscode/\\n\\n# Ruff stuff:\\n.ruff_cache/\\n\\n# PyPI configuration file\\n.pypirc\\n\\n# Cursor\\n#  Cursor is an AI-powered code editor. `.cursorignore` specifies files/directories to\\n#  exclude from AI features like autocomplete and code analysis. Recommended for sensitive data\\n#  refer to https://docs.cursor.com/context/ignore-files\\n.cursorignore\\n.cursorindexingignore\\n\\n# Marimo\\nmarimo/_static/\\nmarimo/_lsp/\\n__marimo__/\\n"
            },
            {
                "type": "directory",
                "name": ".idea",
                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\.idea",
                "children": [
                    {
                        "type": "file",
                        "name": ".gitignore",
                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\.idea\\.gitignore",
                        "size_bytes": 50,
                        "content": "# Default ignored files\\n/shelf/\\n/workspace.xml\\n"
                    },
                    {
                        "type": "file",
                        "name": "DAYN.iml",
                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\.idea\\DAYN.iml",
                        "size_bytes": 389,
                        "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<module type=\"PYTHON_MODULE\" version=\"4\">\\n  <component name=\"NewModuleRootManager\">\\n    <content url=\"file://$MODULE_DIR$\" />\\n    <orderEntry type=\"jdk\" jdkName=\"Python 3.13 virtualenv at C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\.venv\" jdkType=\"Python SDK\" />\\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\\n  </component>\\n</module>"
                    },
                    {
                        "type": "directory",
                        "name": "inspectionProfiles",
                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\.idea\\inspectionProfiles",
                        "children": [
                            {
                                "type": "file",
                                "name": "profiles_settings.xml",
                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\.idea\\inspectionProfiles\\profiles_settings.xml",
                                "size_bytes": 174,
                                "content": "<component name=\"InspectionProjectProfileManager\">\\n  <settings>\\n    <option name=\"USE_PROJECT_PROFILE\" value=\"false\" />\\n    <version value=\"1.0\" />\\n  </settings>\\n</component>"
                            },
                            {
                                "type": "file",
                                "name": "Project_Default.xml",
                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\.idea\\inspectionProfiles\\Project_Default.xml",
                                "size_bytes": 1769,
                                "content": "<component name=\"InspectionProjectProfileManager\">\\n  <profile version=\"1.0\">\\n    <option name=\"myName\" value=\"Project Default\" />\\n    <inspection_tool class=\"PyInterpreterInspection\" enabled=\"false\" level=\"WARNING\" enabled_by_default=\"false\" />\\n    <inspection_tool class=\"PyPackageRequirementsInspection\" enabled=\"true\" level=\"WARNING\" enabled_by_default=\"true\">\\n      <option name=\"ignoredPackages\">\\n        <value>\\n          <list size=\"14\">\\n            <item index=\"0\" class=\"java.lang.String\" itemvalue=\"pytest\" />\\n            <item index=\"1\" class=\"java.lang.String\" itemvalue=\"pydantic-settings\" />\\n            <item index=\"2\" class=\"java.lang.String\" itemvalue=\"fastapi\" />\\n            <item index=\"3\" class=\"java.lang.String\" itemvalue=\"pydantic\" />\\n            <item index=\"4\" class=\"java.lang.String\" itemvalue=\"pydantic-extra-types\" />\\n            <item index=\"5\" class=\"java.lang.String\" itemvalue=\"pydantic_core\" />\\n            <item index=\"6\" class=\"java.lang.String\" itemvalue=\"psycopg\" />\\n            <item index=\"7\" class=\"java.lang.String\" itemvalue=\"psycopg-binary\" />\\n            <item index=\"8\" class=\"java.lang.String\" itemvalue=\"uvicorn\" />\\n            <item index=\"9\" class=\"java.lang.String\" itemvalue=\"motpy\" />\\n            <item index=\"10\" class=\"java.lang.String\" itemvalue=\"aiosqlite\" />\\n            <item index=\"11\" class=\"java.lang.String\" itemvalue=\"aiogram\" />\\n            <item index=\"12\" class=\"java.lang.String\" itemvalue=\"python-dotenv\" />\\n            <item index=\"13\" class=\"java.lang.String\" itemvalue=\"sqlalchemy\" />\\n          </list>\\n        </value>\\n      </option>\\n    </inspection_tool>\\n    <inspection_tool class=\"YAMLSchemaValidation\" enabled=\"false\" level=\"WARNING\" enabled_by_default=\"false\" />\\n  </profile>\\n</component>"
                            }
                        ]
                    },
                    {
                        "type": "file",
                        "name": "misc.xml",
                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\.idea\\misc.xml",
                        "size_bytes": 380,
                        "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<project version=\"4\">\\n  <component name=\"Black\">\\n    <option name=\"sdkName\" value=\"Python 3.11 (-fse-exam-api-august2025-main)\" />\\n  </component>\\n  <component name=\"ProjectRootManager\" version=\"2\" project-jdk-name=\"Python 3.13 virtualenv at C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\.venv\" project-jdk-type=\"Python SDK\" />\\n</project>"
                    },
                    {
                        "type": "file",
                        "name": "modules.xml",
                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\.idea\\modules.xml",
                        "size_bytes": 267,
                        "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<project version=\"4\">\\n  <component name=\"ProjectModuleManager\">\\n    <modules>\\n      <module fileurl=\"file://$PROJECT_DIR$/.idea/DAYN.iml\" filepath=\"$PROJECT_DIR$/.idea/DAYN.iml\" />\\n    </modules>\\n  </component>\\n</project>"
                    },
                    {
                        "type": "file",
                        "name": "vcs.xml",
                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\.idea\\vcs.xml",
                        "size_bytes": 172,
                        "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<project version=\"4\">\\n  <component name=\"VcsDirectoryMappings\">\\n    <mapping directory=\"\" vcs=\"Git\" />\\n  </component>\\n</project>"
                    },
                    {
                        "type": "file",
                        "name": "workspace.xml",
                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\.idea\\workspace.xml",
                        "size_bytes": 4228,
                        "content": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<project version=\"4\">\\n  <component name=\"AutoImportSettings\">\\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\\n  </component>\\n  <component name=\"ChangeListManager\">\\n    <list default=\"true\" id=\"eeac35be-ca9b-41eb-a7c2-7490de9f5a4a\" name=\"Changes\" comment=\"\">\\n      <change beforePath=\"$PROJECT_DIR$/README.md\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/README.md\" afterDir=\"false\" />\\n    </list>\\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\\n  </component>\\n  <component name=\"FileTemplateManagerImpl\">\\n    <option name=\"RECENT_TEMPLATES\">\\n      <list>\\n        <option value=\"Python Script\" />\\n      </list>\\n    </option>\\n  </component>\\n  <component name=\"Git.Settings\">\\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\\n  </component>\\n  <component name=\"GitHubPullRequestSearchHistory\">{\\n  &quot;lastFilter&quot;: {\\n    &quot;state&quot;: &quot;OPEN&quot;,\\n    &quot;assignee&quot;: &quot;DenysHerasymchuk&quot;\\n  }\\n}</component>\\n  <component name=\"GithubPullRequestsUISettings\">{\\n  &quot;selectedUrlAndAccountId&quot;: {\\n    &quot;url&quot;: &quot;https://github.com/DenysHerasymchuk/DAYN.git&quot;,\\n    &quot;accountId&quot;: &quot;7c4f1918-a3b1-48be-a39b-aa12eea59358&quot;\\n  }\\n}</component>\\n  <component name=\"ProjectColorInfo\">{\\n  &quot;associatedIndex&quot;: 8\\n}</component>\\n  <component name=\"ProjectId\" id=\"38RHk3Ix59NTThepR1gzPkdh8CX\" />\\n  <component name=\"ProjectLevelVcsManager\">\\n    <ConfirmationsSetting value=\"1\" id=\"Add\" />\\n  </component>\\n  <component name=\"ProjectViewState\">\\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\\n    <option name=\"showLibraryContents\" value=\"true\" />\\n  </component>\\n  <component name=\"PropertiesComponent\"><![CDATA[{\\n  \"keyToString\": {\\n    \"ASKED_SHARE_PROJECT_CONFIGURATION_FILES\": \"true\",\\n    \"Python.dump.executor\": \"Run\",\\n    \"Python.file_manager.executor\": \"Run\",\\n    \"Python.main.executor\": \"Run\",\\n    \"Python.run.executor\": \"Run\",\\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\\n    \"RunOnceActivity.git.unshallow\": \"true\",\\n    \"git-widget-placeholder\": \"main\",\\n    \"last_opened_file_path\": \"C:/Users/HomePC/Desktop/works/Telegram/DAYN/app/downloader/tiktok\"\\n  }\\n}]]></component>\\n  <component name=\"RecentsManager\">\\n    <key name=\"CopyFile.RECENT_KEYS\">\\n      <recent name=\"C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\downloader\\tiktok\" />\\n      <recent name=\"C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\" />\\n      <recent name=\"C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\temp\" />\\n    </key>\\n    <key name=\"MoveFile.RECENT_KEYS\">\\n      <recent name=\"C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\handlers\\common\" />\\n      <recent name=\"C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\config\" />\\n      <recent name=\"C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\utils\" />\\n      <recent name=\"C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\" />\\n      <recent name=\"C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\src\" />\\n    </key>\\n  </component>\\n  <component name=\"SharedIndexes\">\\n    <attachedChunks>\\n      <set>\\n        <option value=\"bundled-python-sdk-495700d161d3-aa17d162503b-com.jetbrains.pycharm.community.sharedIndexes.bundled-PC-243.22562.220\" />\\n      </set>\\n    </attachedChunks>\\n  </component>\\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\\n  <component name=\"TaskManager\">\\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\\n      <changelist id=\"eeac35be-ca9b-41eb-a7c2-7490de9f5a4a\" name=\"Changes\" comment=\"\" />\\n      <created>1768755603163</created>\\n      <option name=\"number\" value=\"Default\" />\\n      <option name=\"presentableId\" value=\"Default\" />\\n      <updated>1768755603163</updated>\\n    </task>\\n    <servers />\\n  </component>\\n  <component name=\"UnknownFeatures\">\\n    <option featureType=\"com.intellij.fileTypeFactory\" implementationName=\".env\" />\\n  </component>\\n</project>"
                    }
                ]
            },
            {
                "type": "directory",
                "name": "app",
                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app",
                "children": [
                    {
                        "type": "directory",
                        "name": "bot",
                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot",
                        "children": [
                            {
                                "type": "directory",
                                "name": "handlers",
                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\handlers",
                                "children": [
                                    {
                                        "type": "directory",
                                        "name": "common",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\handlers\\common",
                                        "children": [
                                            {
                                                "type": "file",
                                                "name": "cancel.py",
                                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\handlers\\common\\cancel.py",
                                                "size_bytes": 515,
                                                "content": "from aiogram import Router, F\\nfrom aiogram.types import CallbackQuery\\nfrom aiogram.fsm.context import FSMContext\\n\\nrouter = Router()\\n\\n\\n@router.callback_query(F.data == \"cancel\")\\nasync def cancel_callback(callback: CallbackQuery, state: FSMContext):\\n    \"\"\"Handle cancel action.\"\"\"\\n    await callback.answer(\"Cancelled\")\\n    await state.clear()\\n\\n    try:\\n        await callback.message.edit_text(\"\u274c Operation cancelled.\")\\n    except:\\n        await callback.message.answer(\"\u274c Operation cancelled.\")"
                                            },
                                            {
                                                "type": "file",
                                                "name": "start.py",
                                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\handlers\\common\\start.py",
                                                "size_bytes": 1270,
                                                "content": "from aiogram import Router, F\\nfrom aiogram.types import Message\\nfrom aiogram.filters import CommandStart, Command\\n\\nfrom app.config.settings import settings\\nfrom app.config.constants import Emojis, Messages\\n\\nrouter = Router()\\n\\n\\n@router.message(CommandStart())\\nasync def start_handler(message: Message):\\n    \"\"\"Handle /start command.\"\"\"\\n    max_size_mb = settings.MAX_FILE_SIZE / (1024 * 1024)\\n    premium_status = \"\u2705 Premium (2GB limit)\" if settings.PREMIUM else \"\ud83d\udce6 Regular (50MB limit)\"\\n\\n    await message.answer(\\n        Messages.START.format(\\n            video=Emojis.VIDEO,\\n            light=Emojis.LIGHT,\\n            gear=Emojis.GEAR,\\n            status=premium_status\\n        ),\\n        parse_mode=\"HTML\"\\n    )\\n\\n\\n@router.message(Command(\"help\"))\\nasync def help_handler(message: Message):\\n    \"\"\"Handle /help command.\"\"\"\\n    max_size_mb = settings.MAX_FILE_SIZE / (1024 * 1024)\\n    limit_text = f\"Only qualities under {max_size_mb:.0f}MB are shown\" if not settings.PREMIUM else f\"Can download files up to {max_size_mb:.0f}MB\"\\n\\n    await message.answer(\\n        Messages.HELP.format(\\n            help=Emojis.HELP,\\n            light=Emojis.LIGHT,\\n            limit_text=limit_text\\n        ),\\n        parse_mode=\"HTML\"\\n    )"
                                            },
                                            {
                                                "type": "file",
                                                "name": "__init__.py",
                                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\handlers\\common\\__init__.py",
                                                "size_bytes": 210,
                                                "content": "from aiogram import Router\\nfrom .start import router as start_router\\nfrom .cancel import router as cancel_router\\n\\nrouter = Router()\\nrouter.include_router(start_router)\\nrouter.include_router(cancel_router)"
                                            },
                                            {
                                                "type": "directory",
                                                "name": "__pycache__",
                                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\handlers\\common\\__pycache__",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "type": "directory",
                                        "name": "tiktok",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\handlers\\tiktok",
                                        "children": [
                                            {
                                                "type": "file",
                                                "name": "callbacks.py",
                                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\handlers\\tiktok\\callbacks.py",
                                                "size_bytes": 5893,
                                                "content": "import os\\nimport logging\\nimport time\\nfrom aiogram import Router, F\\nfrom aiogram.types import CallbackQuery, FSInputFile\\nfrom aiogram.fsm.context import FSMContext\\n\\nfrom app.config.settings import settings\\nfrom app.bot.keyboards.tiktok_kb import get_audio_button\\nfrom app.bot.utils.progress import create_video_progress_bar\\nfrom app.bot.utils.logger import user_logger\\nfrom . import tiktok_dl\\n\\nlogger = logging.getLogger(__name__)\\nrouter = Router()\\n\\n\\n# TikTok Callbacks\\n@router.callback_query(F.data == \"tiktok_extract_audio\")\\nasync def tiktok_extract_audio_callback(callback: CallbackQuery, state: FSMContext):\\n    \"\"\"Handle TikTok audio extraction from video.\"\"\"\\n\\n    user_id = callback.from_user.id\\n\\n    try:\\n        # Get data from state\\n        data = await state.get_data()\\n        url = data.get('url')\\n        video_info = data.get('video_info', {})\\n\\n        # CHECK TIMESTAMP\\n        timestamp = data.get('timestamp', 0)\\n        current_time = time.time()\\n\\n        # Clear state if older than 24 hours (86400 seconds)\\n        if current_time - timestamp > 86400:\\n            await state.clear()\\n            user_logger.log_user_action(\\n                \"tiktok_extract_audio_callback\",\\n                user_id,\\n                \"Session expired\",\\n                f\"Age: {current_time - timestamp:.0f}s\"\\n            )\\n            await callback.answer(\"\u23f3 Session expired. Please send the TikTok URL again.\", show_alert=True)\\n\\n            # Remove the audio button\\n            try:\\n                await callback.message.edit_reply_markup(reply_markup=None)\\n            except:\\n                pass\\n            return\\n\\n        if not url:\\n            user_logger.log_user_error(\\n                \"tiktok_extract_audio_callback\",\\n                user_id,\\n                \"No URL in state\"\\n            )\\n            # Try to get URL from the original message text\\n            try:\\n                video_message_id = data.get('video_message_id')\\n                if video_message_id:\\n                    await callback.message.reply(\\n                        \"\u26a0\ufe0f Session expired. Please send the TikTok URL again for audio extraction.\"\\n                    )\\n                    await state.clear()\\n                    return\\n            except:\\n                pass\\n\\n            await callback.message.edit_reply_markup(reply_markup=None)\\n            await callback.message.reply(\"\u274c Please send the TikTok URL again for audio extraction.\")\\n            await state.clear()\\n            return\\n\\n        # Log audio extraction start\\n        user_logger.log_user_action(\\n            \"tiktok_extract_audio_callback\",\\n            user_id,\\n            \"Audio extraction started\",\\n            f\"User: @{video_info.get('author', 'unknown')}\"\\n        )\\n\\n        # Send status message\\n        status_msg = await callback.message.reply(\"\ud83c\udfb5 Extracting audio...\")\\n\\n        # Progress callback\\n        async def update_progress(percent):\\n            try:\\n                progress_bar = create_video_progress_bar(percent)\\n                await status_msg.edit_text(f\"\ud83c\udfb5 Extracting audio... {int(percent)}%\\n{progress_bar}\")\\n            except:\\n                pass\\n\\n        # Log download start\\n        user_logger.log_download_start(\"tiktok_audio\", user_id, url)\\n\\n        # Download audio directly from the URL\\n        file_path = await tiktok_dl.download_audio(url, progress_callback=update_progress)\\n\\n        # Check file size\\n        file_size = os.path.getsize(file_path)\\n        file_size_mb = file_size / (1024 * 1024)\\n\\n        if file_size > settings.MAX_FILE_SIZE:\\n            user_logger.log_user_error(\\n                \"tiktok_extract_audio_callback\",\\n                user_id,\\n                f\"Audio too large: {file_size_mb:.1f}MB\"\\n            )\\n            await status_msg.edit_text(\\n                f\"\u274c Audio too large ({file_size_mb:.1f} MB)\\n\"\\n                f\"Limit: {settings.MAX_FILE_SIZE / (1024 * 1024):.0f} MB\"\\n            )\\n            if os.path.exists(file_path):\\n                os.remove(file_path)\\n            return\\n\\n        # Get bot username\\n        bot_me = await callback.bot.get_me()\\n        bot_username = f\"@{bot_me.username}\" if bot_me.username else \"\"\\n\\n        # Create author link\\n        username = video_info.get('author', 'unknown')\\n        author_link = f'<a href=\"https://www.tiktok.com/@{username}\">@{username}</a>'\\n\\n        # Send audio\\n        await callback.bot.send_audio(\\n            chat_id=callback.message.chat.id,\\n            audio=FSInputFile(file_path),\\n            title=f\"TikTok Audio - @{username}\"[:64],\\n            performer=username[:64],\\n            caption=f\"\ud83c\udfb5 TikTok Audio\\n\ud83d\udc64 {author_link}\\n\\nDownloaded via:\\n{bot_username}\",\\n            parse_mode=\"HTML\"\\n        )\\n\\n        # Log successful extraction\\n        user_logger.log_download_complete(\"tiktok_audio\", user_id, file_size_mb, success=True)\\n        user_logger.log_user_action(\\n            \"tiktok_extract_audio_callback\",\\n            user_id,\\n            \"Audio extracted and sent\",\\n            f\"Size: {file_size_mb:.1f}MB\"\\n        )\\n\\n        # Cleanup\\n        if os.path.exists(file_path):\\n            os.remove(file_path)\\n\\n        # Delete status message\\n        await status_msg.delete()\\n\\n        # Remove the audio button from original message\\n        try:\\n            await callback.message.edit_reply_markup(reply_markup=None)\\n        except:\\n            pass\\n\\n    except Exception as e:\\n        user_logger.log_user_error(\\n            \"tiktok_extract_audio_callback\",\\n            user_id,\\n            f\"TikTok audio extraction error: {str(e)}\"\\n        )\\n        try:\\n            await callback.message.reply(\"\u274c Audio extraction failed. Please try again.\")\\n        except:\\n            pass"
                                            },
                                            {
                                                "type": "file",
                                                "name": "photo_handler.py",
                                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\handlers\\tiktok\\photo_handler.py",
                                                "size_bytes": 6168,
                                                "content": "\"\"\"\\nPhoto-specific handler for TikTok photo posts.\\nThis contains logic extracted from the main TikTok handler.\\n\"\"\"\\nimport os\\nimport logging\\n\\nfrom aiogram import Router\\nfrom aiogram.types import Message, InputMediaPhoto, FSInputFile\\nfrom aiogram.fsm.context import FSMContext\\n\\nfrom app.bot.keyboards.tiktok_kb import get_audio_button\\nfrom app.bot.utils.logger import user_logger\\n\\nlogger = logging.getLogger(__name__)\\nrouter = Router()\\n\\n\\nasync def send_tiktok_photos(\\n        message: Message,\\n        images: list,\\n        author_link: str,\\n        bot_username: str,\\n        state: FSMContext,\\n        user_id: int\\n):\\n    \"\"\"\\n    Send TikTok photos without captions in media group.\\n    Only final summary message gets caption with info.\\n\\n    Args:\\n        message: Original message object\\n        images: List of image file paths\\n        author_link: HTML formatted author link\\n        bot_username: Bot's username\\n        state: FSM context\\n        user_id: Telegram user ID for logging\\n    \"\"\"\\n    total_photos = len(images)\\n    batch_size = 10  # Telegram media group limit\\n\\n    # Log photo sending start\\n    user_logger.log_user_action(\\n        \"photo_handler.send_tiktok_photos\",\\n        user_id,\\n        f\"Sending {total_photos} TikTok photos\",\\n        f\"Author: {author_link}\"\\n    )\\n\\n    # Send photos in batches of 10 WITHOUT CAPTIONS\\n    for batch_num, i in enumerate(range(0, total_photos, batch_size), 1):\\n        batch = images[i:i + batch_size]\\n\\n        media_group = []\\n        for img_path in batch:\\n            if not os.path.exists(img_path):\\n                logger.warning(f\"Image file not found: {img_path}\")\\n                continue\\n\\n            # Check if file is valid\\n            try:\\n                file_size = os.path.getsize(img_path)\\n                if file_size == 0:\\n                    logger.error(f\"Empty image file: {img_path}\")\\n                    continue\\n            except OSError as e:\\n                logger.error(f\"Could not read image file {img_path}: {e}\")\\n                continue\\n\\n            # NO CAPTION - just send the photo\\n            media_group.append(\\n                InputMediaPhoto(\\n                    media=FSInputFile(img_path)\\n                )\\n            )\\n\\n        if media_group:\\n            try:\\n                await message.reply_media_group(media=media_group)\\n                logger.debug(f\"\u2713 Sent batch {batch_num} with {len(media_group)} photos\")\\n\\n                # Log batch sent\\n                user_logger.log_user_action(\\n                    \"photo_handler.send_tiktok_photos\",\\n                    user_id,\\n                    f\"Photo batch {batch_num} sent\",\\n                    f\"Photos: {len(media_group)}\"\\n                )\\n\\n            except Exception as e:\\n                logger.error(f\"\u2717 Failed to send batch {batch_num}: {e}\")\\n                user_logger.log_user_error(\\n                    \"photo_handler.send_tiktok_photos\",\\n                    user_id,\\n                    f\"Failed to send photo batch {batch_num}: {str(e)}\"\\n                )\\n\\n                # Fallback: send photos one by one\\n                for img_path in batch:\\n                    if os.path.exists(img_path):\\n                        try:\\n                            await message.reply_photo(FSInputFile(img_path))\\n                        except Exception as e2:\\n                            logger.error(f\"Failed to send individual photo: {e2}\")\\n\\n    # Send final summary message with audio button\\n    final_msg = await message.reply(\\n        f\"\ud83d\udcf8 TikTok Photos ({total_photos} images)\\n\"\\n        f\"\ud83d\udc64 {author_link}\\n\\n\"\\n        f\"{bot_username}\",\\n        parse_mode=\"HTML\",\\n        reply_markup=get_audio_button()\\n    )\\n\\n    # Store state for audio extraction\\n    await state.update_data(\\n        final_message_id=final_msg.message_id,\\n        total_photos=total_photos,\\n        user_id=user_id  # Store user_id for callback context\\n    )\\n\\n    logger.info(f\"\u2713 Sent final summary with audio button for {total_photos} photos\")\\n\\n    # Log final message sent\\n    user_logger.log_user_action(\\n        \"photo_handler.send_tiktok_photos\",\\n        user_id,\\n        \"Final summary sent\",\\n        f\"Total photos: {total_photos} | Message ID: {final_msg.message_id}\"\\n    )\\n\\n    return final_msg\\n\\n\\nasync def handle_single_photo(\\n        message: Message,\\n        image_path: str,\\n        author_link: str,\\n        bot_username: str,\\n        state: FSMContext,\\n        user_id: int\\n):\\n    \"\"\"\\n    Handle single TikTok photo download.\\n\\n    Args:\\n        message: Original message object\\n        image_path: Path to the single image\\n        author_link: HTML formatted author link\\n        bot_username: Bot's username\\n        state: FSM context\\n        user_id: Telegram user ID for logging\\n    \"\"\"\\n    try:\\n        # Log single photo handling\\n        user_logger.log_user_action(\\n            \"photo_handler.handle_single_photo\",\\n            user_id,\\n            \"Sending single TikTok photo\",\\n            f\"Author: {author_link}\"\\n        )\\n\\n        # Send single photo with caption and button\\n        photo_msg = await message.reply_photo(\\n            photo=FSInputFile(image_path),\\n            caption=f\"\ud83d\udcf8 TikTok Photo\\n\ud83d\udc64 {author_link}\\n\\nDownloaded via:\\n{bot_username}\",\\n            parse_mode=\"HTML\",\\n            reply_markup=get_audio_button()\\n        )\\n\\n        # Store state for audio extraction\\n        await state.update_data(\\n            photo_message_id=photo_msg.message_id,\\n            total_photos=1,\\n            user_id=user_id\\n        )\\n\\n        # Log success\\n        user_logger.log_user_action(\\n            \"photo_handler.handle_single_photo\",\\n            user_id,\\n            \"Single photo sent\",\\n            f\"Message ID: {photo_msg.message_id}\"\\n        )\\n\\n        return photo_msg\\n\\n    except Exception as e:\\n        user_logger.log_user_error(\\n            \"photo_handler.handle_single_photo\",\\n            user_id,\\n            f\"Failed to send single photo: {str(e)}\"\\n        )\\n        raise"
                                            },
                                            {
                                                "type": "file",
                                                "name": "url_handler.py",
                                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\handlers\\tiktok\\url_handler.py",
                                                "size_bytes": 8204,
                                                "content": "import os\\nimport logging\\nimport time\\nimport asyncio\\n\\nfrom aiogram import Router\\nfrom aiogram.types import Message, FSInputFile\\nfrom aiogram.fsm.context import FSMContext\\n\\nfrom app.config.settings import settings\\nfrom app.bot.states.download_states import TikTokState\\nfrom app.bot.keyboards.tiktok_kb import get_audio_button\\nfrom app.bot.utils.validators import is_tiktok_url\\nfrom app.bot.utils.progress import create_video_progress_bar\\nfrom app.bot.utils.logger import user_logger\\nfrom .photo_handler import send_tiktok_photos, handle_single_photo\\nfrom . import tiktok_dl\\n\\nlogger = logging.getLogger(__name__)\\nrouter = Router()\\n\\n\\ndef tiktok_url_filter(message: Message) -> bool:\\n    \"\"\"Filter for TikTok URLs only.\"\"\"\\n    return bool(message.text and is_tiktok_url(message.text.strip()))\\n\\nasync def cleanup_files(file_paths, user_id: int = None):\\n    \"\"\"Clean up files using file manager with user logging.\"\"\"\\n    from app.core.file_manager import file_manager\\n\\n    if not file_paths:\\n        return\\n\\n    # Log cleanup if user_id provided\\n    if user_id:\\n        user_logger.log_user_action(\\n            \"url_handler.cleanup_files\",\\n            user_id,\\n            \"Cleaning up temporary files\",\\n            f\"Files: {len(file_paths)}\"\\n        )\\n\\n    # Clean up files using file manager\\n    deleted_count = await file_manager.cleanup_files(file_paths)\\n\\n    # Log result if user_id provided\\n    if user_id and deleted_count > 0:\\n        user_logger.log_user_action(\\n            \"url_handler.cleanup_files\",\\n            user_id,\\n            \"Files cleaned up\",\\n            f\"Deleted: {deleted_count}/{len(file_paths)} files\"\\n        )\\n\\n\\n@router.message(tiktok_url_filter)\\nasync def tiktok_url_handler(message: Message, state: FSMContext):\\n    \"\"\"Handle TikTok URL - instantly download and send.\"\"\"\\n    user_id = message.from_user.id\\n    url = message.text.strip()\\n\\n    # Log user action\\n    user_logger.log_user_action(\\n        \"tiktok_url_handler\",\\n        user_id,\\n        \"TikTok URL received\",\\n        f\"URL: {url[:50]}...\"\\n    )\\n\\n    try:\\n        # Store URL in state immediately for potential audio extraction\\n        await state.update_data(\\n            url=url,\\n            timestamp=time.time(),  # Store creation time\\n            platform=\"tiktok\"\\n        )\\n\\n        # Send initial status\\n        status_msg = await message.reply(\"\u23f3 Processing TikTok link...\")\\n\\n        # Get video info\\n        video_info = await tiktok_dl.get_video_info(url)\\n        username = video_info.get('author', 'unknown')\\n        content_type = video_info.get('content_type', 'video')\\n\\n        # Log video info\\n        user_logger.log_user_action(\\n            \"tiktok_url_handler\",\\n            user_id,\\n            \"TikTok info retrieved\",\\n            f\"User: @{username} | Type: {content_type}\"\\n        )\\n\\n        # Store video info in state\\n        await state.update_data(video_info=video_info)\\n        await state.set_state(TikTokState.selecting_format)\\n\\n        # Update status\\n        await status_msg.edit_text(f\"\u2b07\ufe0f Downloading {'photos' if content_type == 'photo' else 'video'}...\")\\n\\n        # Log download start\\n        user_logger.log_download_start(\"tiktok\", user_id, url)\\n\\n        # Progress callback\\n        async def update_progress(percent):\\n            try:\\n                progress_bar = create_video_progress_bar(percent)\\n                await status_msg.edit_text(\\n                    f\"\u2b07\ufe0f Downloading... {int(percent)}%\\n{progress_bar}\"\\n                )\\n            except:\\n                pass\\n\\n        # Download content\\n        content = await tiktok_dl.download_video(url, progress_callback=update_progress)\\n\\n        # Calculate file size for logging\\n        if isinstance(content, list):\\n            # Photos\\n            total_size = sum(os.path.getsize(f) for f in content if os.path.exists(f))\\n        else:\\n            # Video\\n            total_size = os.path.getsize(content) if os.path.exists(content) else 0\\n\\n        file_size_mb = total_size / (1024 * 1024)\\n\\n        # Log download completion\\n        user_logger.log_download_complete(\"tiktok\", user_id, file_size_mb)\\n\\n        # Get bot username for caption\\n        bot_me = await message.bot.get_me()\\n        bot_username = f\"@{bot_me.username}\" if bot_me.username else \"\"\\n\\n        # Create author link\\n        author_link = f'<a href=\"https://www.tiktok.com/@{username}\">@{username}</a>'\\n\\n        if isinstance(content, list):\\n            # It's photos\\n            images = content\\n            total_downloaded = len(images)\\n\\n            if total_downloaded == 1:\\n                # Single photo - send with both captions and button\\n                await status_msg.edit_text(\"\ud83d\udce4 Sending photo...\")\\n\\n                # Use photo handler\\n                photo_msg = await handle_single_photo(\\n                    message=message,\\n                    image_path=images[0],\\n                    author_link=author_link,\\n                    bot_username=bot_username,\\n                    state=state,\\n                    user_id=user_id\\n                )\\n\\n                # Cleanup in background\\n                asyncio.create_task(cleanup_files([images[0]], user_id))\\n\\n            else:\\n                # Multiple photos - use helper function\\n                await status_msg.edit_text(f\"\ud83d\udce4 Sending {total_downloaded} photos...\")\\n\\n                # Use photo handler\\n                await send_tiktok_photos(\\n                    message=message,\\n                    images=images,\\n                    author_link=author_link,\\n                    bot_username=bot_username,\\n                    state=state,\\n                    user_id=user_id\\n                )\\n\\n                # Cleanup in background AFTER sending\\n                asyncio.create_task(cleanup_files(images, user_id))\\n\\n        else:\\n            # It's a video\\n            await status_msg.edit_text(\"\ud83d\udce4 Sending video...\")\\n\\n            file_path = content\\n            file_size = os.path.getsize(file_path)\\n            file_size_mb = file_size / (1024 * 1024)\\n\\n            if file_size > settings.MAX_FILE_SIZE:\\n                # Log error\\n                user_logger.log_user_error(\\n                    \"tiktok_url_handler\",\\n                    user_id,\\n                    f\"File too large: {file_size_mb:.1f}MB\"\\n                )\\n                await status_msg.edit_text(\\n                    f\"\u274c Video too large ({file_size_mb:.1f} MB)\\n\"\\n                    f\"Limit: {settings.MAX_FILE_SIZE / (1024 * 1024):.0f} MB\"\\n                )\\n                if os.path.exists(file_path):\\n                    os.remove(file_path)\\n                return\\n\\n            # Send video with caption and button\\n            video_msg = await message.reply_video(\\n                video=FSInputFile(file_path),\\n                caption=f\"\ud83c\udfac TikTok Video\\n\ud83d\udc64 {author_link}\\n\ud83d\udcbe {file_size_mb:.1f} MB\\n\\nDownloaded via:\\n{bot_username}\",\\n                parse_mode=\"HTML\",\\n                supports_streaming=True,\\n                reply_markup=get_audio_button()\\n            )\\n\\n            # Store the message ID for potential audio extraction\\n            await state.update_data(video_message_id=video_msg.message_id)\\n\\n            # Cleanup video file in background\\n            asyncio.create_task(cleanup_files([file_path], user_id))\\n\\n        # Delete status message\\n        try:\\n            await status_msg.delete()\\n        except:\\n            pass\\n\\n    except Exception as e:\\n        # Log error\\n        user_logger.log_user_error(\\n            \"tiktok_url_handler\",\\n            user_id,\\n            f\"TikTok download error: {str(e)}\"\\n        )\\n        try:\\n            await status_msg.edit_text(\\n                f\"\u274c Error downloading TikTok content.\\n\"\\n                f\"Please check the URL and try again.\"\\n            )\\n        except:\\n            await message.reply(\\n                f\"\u274c Error downloading TikTok content.\\n\"\\n                f\"Please check the URL and try again.\"\\n            )\\n        await state.clear()"
                                            },
                                            {
                                                "type": "file",
                                                "name": "__init__.py",
                                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\handlers\\tiktok\\__init__.py",
                                                "size_bytes": 427,
                                                "content": "from aiogram import Router\\nfrom app.downloader.tiktok import TikTokDownloader\\n\\n# Shared downloader instance\\ntiktok_dl = TikTokDownloader()\\n\\nfrom .url_handler import router as url_router\\nfrom .callbacks import router as callbacks_router\\nfrom .photo_handler import router as photo_router\\n\\nrouter = Router()\\nrouter.include_router(url_router)\\nrouter.include_router(callbacks_router)\\nrouter.include_router(photo_router)"
                                            },
                                            {
                                                "type": "directory",
                                                "name": "__pycache__",
                                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\handlers\\tiktok\\__pycache__",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "type": "directory",
                                        "name": "youtube",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\handlers\\youtube",
                                        "children": [
                                            {
                                                "type": "file",
                                                "name": "callbacks.py",
                                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\handlers\\youtube\\callbacks.py",
                                                "size_bytes": 9809,
                                                "content": "import os\\nimport logging\\nfrom aiogram import Router, F\\nfrom aiogram.types import CallbackQuery, FSInputFile\\nfrom aiogram.fsm.context import FSMContext\\n\\nfrom app.config.settings import settings\\nfrom app.bot.utils.progress import create_video_progress_bar\\nfrom app.bot.states.download_states import YouTubeState\\nfrom app.bot.utils.logger import user_logger\\nfrom . import youtube_dl\\n\\nlogger = logging.getLogger(__name__)\\nrouter = Router()\\n\\n\\n# YouTube Callbacks\\n@router.callback_query(F.data.startswith(\"quality_\"), YouTubeState.selecting_quality)\\nasync def youtube_quality_callback(callback: CallbackQuery, state: FSMContext):\\n    \"\"\"Handle YouTube quality selection.\"\"\"\\n    await callback.answer()\\n\\n    user_id = callback.from_user.id\\n\\n    try:\\n        # Get data from state\\n        data = await state.get_data()\\n        video_info = data.get('video_info')\\n        url = data.get('url')\\n\\n        if not video_info or not url:\\n            user_logger.log_user_error(\\n                \"youtube_quality_callback\",\\n                user_id,\\n                \"Session expired - missing video_info or url\"\\n            )\\n            await callback.message.edit_text(\"\u274c Session expired. Please send the URL again.\")\\n            await state.clear()\\n            return\\n\\n        # Extract quality\\n        quality = int(callback.data.split('_')[1])\\n\\n        # Log quality selection\\n        user_logger.log_user_action(\\n            \"youtube_quality_callback\",\\n            user_id,\\n            \"Quality selected\",\\n            f\"Quality: {quality}p | Title: {video_info.get('title', 'Unknown')[:50]}\"\\n        )\\n\\n        # Update message with progress\\n        progress_bar = create_video_progress_bar(0)\\n        try:\\n            await callback.message.edit_caption(\\n                caption=f\"\u2b07\ufe0f Downloading {quality}p video...\\n{progress_bar}\",\\n                parse_mode=\"HTML\"\\n            )\\n        except:\\n            await callback.message.edit_text(\\n                f\"\u2b07\ufe0f Downloading {quality}p video...\\n{progress_bar}\"\\n            )\\n\\n        # Progress callback\\n        async def update_progress(percent):\\n            try:\\n                progress_bar = create_video_progress_bar(percent)\\n                try:\\n                    await callback.message.edit_caption(\\n                        caption=f\"\u2b07\ufe0f Downloading {quality}p video...\\n{progress_bar}\",\\n                        parse_mode=\"HTML\"\\n                    )\\n                except:\\n                    await callback.message.edit_text(\\n                        f\"\u2b07\ufe0f Downloading {quality}p video...\\n{progress_bar}\"\\n                    )\\n            except:\\n                pass\\n\\n        # Log download start\\n        user_logger.log_download_start(\"youtube\", user_id, url, f\"{quality}p\")\\n\\n        # Download video\\n        await state.set_state(YouTubeState.downloading_video)\\n        file_path = await youtube_dl.download_video(\\n            url,\\n            quality=quality,\\n            progress_callback=update_progress\\n        )\\n\\n        # Check file size\\n        file_size = os.path.getsize(file_path)\\n        file_size_mb = file_size / (1024 * 1024)\\n\\n        if file_size > settings.MAX_FILE_SIZE:\\n            user_logger.log_user_error(\\n                \"youtube_quality_callback\",\\n                user_id,\\n                f\"File too large: {file_size_mb:.1f}MB (limit: {settings.MAX_FILE_SIZE / (1024 * 1024):.0f}MB)\"\\n            )\\n            await callback.message.edit_text(\\n                f\"\u274c File too large ({file_size_mb:.1f} MB)\\n\"\\n                f\"Limit: {settings.MAX_FILE_SIZE / (1024 * 1024):.0f} MB\"\\n            )\\n            if os.path.exists(file_path):\\n                os.remove(file_path)\\n            await state.clear()\\n            return\\n\\n        # Send video\\n        video_file = FSInputFile(file_path)\\n        bot_me = await callback.bot.get_me()\\n        bot_username = f\"@{bot_me.username}\" if bot_me.username else \"\"\\n\\n        await callback.bot.send_video(\\n            chat_id=callback.message.chat.id,\\n            video=video_file,\\n            caption=f\"\u2705 <b>{video_info['title']}</b>\\n\"\\n                    f\"\ud83d\udcfa Quality: {quality}p\\n\"\\n                    f\"\ud83d\udcbe Size: {file_size_mb:.1f} MB\\n\\n\"\\n                    f\"Downloaded via:\\n{bot_username}\",\\n            parse_mode=\"HTML\",\\n            supports_streaming=True\\n        )\\n\\n        # Log successful download\\n        user_logger.log_download_complete(\"youtube\", user_id, file_size_mb, success=True)\\n        user_logger.log_user_action(\\n            \"youtube_quality_callback\",\\n            user_id,\\n            \"Video sent to user\",\\n            f\"Size: {file_size_mb:.1f}MB | Quality: {quality}p\"\\n        )\\n\\n        # Cleanup\\n        if os.path.exists(file_path):\\n            os.remove(file_path)\\n\\n        # Delete options message\\n        try:\\n            await callback.message.delete()\\n        except:\\n            pass\\n\\n        await state.clear()\\n\\n    except Exception as e:\\n        user_logger.log_user_error(\\n            \"youtube_quality_callback\",\\n            user_id,\\n            f\"YouTube download error: {str(e)}\"\\n        )\\n        await callback.message.edit_text(\"\u274c Download failed. Please try again.\")\\n        await state.clear()\\n\\n\\n@router.callback_query(F.data == \"format_audio\", YouTubeState.selecting_quality)\\nasync def youtube_audio_callback(callback: CallbackQuery, state: FSMContext):\\n    \"\"\"Handle YouTube audio download.\"\"\"\\n    await callback.answer()\\n\\n    user_id = callback.from_user.id\\n\\n    try:\\n        # Get data from state\\n        data = await state.get_data()\\n        video_info = data.get('video_info')\\n        url = data.get('url')\\n\\n        if not video_info or not url:\\n            user_logger.log_user_error(\\n                \"youtube_audio_callback\",\\n                user_id,\\n                \"Session expired - missing video_info or url\"\\n            )\\n            await callback.message.edit_text(\"\u274c Session expired. Please send the URL again.\")\\n            await state.clear()\\n            return\\n\\n        # Log audio download selection\\n        user_logger.log_user_action(\\n            \"youtube_audio_callback\",\\n            user_id,\\n            \"Audio download selected\",\\n            f\"Title: {video_info.get('title', 'Unknown')[:50]}\"\\n        )\\n\\n        # Update message with progress\\n        progress_bar = create_video_progress_bar(0)\\n        try:\\n            await callback.message.edit_caption(\\n                caption=f\"\ud83c\udfb5 Downloading audio...\\n{progress_bar}\",\\n                parse_mode=\"HTML\"\\n            )\\n        except:\\n            await callback.message.edit_text(f\"\ud83c\udfb5 Downloading audio...\\n{progress_bar}\")\\n\\n        # Progress callback\\n        async def update_progress(percent):\\n            try:\\n                progress_bar = create_video_progress_bar(percent)\\n                try:\\n                    await callback.message.edit_caption(\\n                        caption=f\"\ud83c\udfb5 Downloading audio...\\n{progress_bar}\",\\n                        parse_mode=\"HTML\"\\n                    )\\n                except:\\n                    await callback.message.edit_text(f\"\ud83c\udfb5 Downloading audio...\\n{progress_bar}\")\\n            except:\\n                pass\\n\\n        # Log download start\\n        user_logger.log_download_start(\"youtube\", user_id, url, \"audio\")\\n\\n        # Download audio\\n        await state.set_state(YouTubeState.downloading_audio)\\n        file_path = await youtube_dl.download_audio(\\n            url,\\n            progress_callback=update_progress\\n        )\\n\\n        # Check file size\\n        file_size = os.path.getsize(file_path)\\n        file_size_mb = file_size / (1024 * 1024)\\n\\n        if file_size > settings.MAX_FILE_SIZE:\\n            user_logger.log_user_error(\\n                \"youtube_audio_callback\",\\n                user_id,\\n                f\"Audio too large: {file_size_mb:.1f}MB (limit: {settings.MAX_FILE_SIZE / (1024 * 1024):.0f}MB)\"\\n            )\\n            await callback.message.edit_text(\\n                f\"\u274c Audio too large ({file_size_mb:.1f} MB)\\n\"\\n                f\"Limit: {settings.MAX_FILE_SIZE / (1024 * 1024):.0f} MB\"\\n            )\\n            if os.path.exists(file_path):\\n                os.remove(file_path)\\n            await state.clear()\\n            return\\n\\n        # Send audio\\n        audio_file = FSInputFile(file_path)\\n        bot_me = await callback.bot.get_me()\\n        bot_username = f\"@{bot_me.username}\" if bot_me.username else \"\"\\n\\n        await callback.bot.send_audio(\\n            chat_id=callback.message.chat.id,\\n            audio=audio_file,\\n            title=video_info.get('title', 'Audio')[:64],\\n            performer=video_info.get('author', 'Unknown')[:64],\\n            caption=f\"{bot_username}\"\\n        )\\n\\n        # Log successful audio download\\n        user_logger.log_download_complete(\"youtube\", user_id, file_size_mb, success=True)\\n        user_logger.log_user_action(\\n            \"youtube_audio_callback\",\\n            user_id,\\n            \"Audio sent to user\",\\n            f\"Size: {file_size_mb:.1f}MB\"\\n        )\\n\\n        # Cleanup\\n        if os.path.exists(file_path):\\n            os.remove(file_path)\\n\\n        # Delete options message\\n        try:\\n            await callback.message.delete()\\n        except:\\n            pass\\n\\n        await state.clear()\\n\\n    except Exception as e:\\n        user_logger.log_user_error(\\n            \"youtube_audio_callback\",\\n            user_id,\\n            f\"YouTube audio download error: {str(e)}\"\\n        )\\n        await callback.message.edit_text(\"\u274c Audio download failed. Please try again.\")\\n        await state.clear()"
                                            },
                                            {
                                                "type": "file",
                                                "name": "url_handler.py",
                                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\handlers\\youtube\\url_handler.py",
                                                "size_bytes": 7539,
                                                "content": "import logging\\nimport time\\nimport asyncio\\nfrom aiogram import Router\\nfrom aiogram.types import Message, URLInputFile\\nfrom aiogram.fsm.context import FSMContext\\n\\nfrom app.config.settings import settings\\nfrom app.bot.keyboards.youtube_kb import get_quality_keyboard_with_sizes\\nfrom app.bot.states.download_states import YouTubeState\\nfrom app.bot.utils.validators import is_youtube_url\\nfrom app.bot.utils.logger import user_logger\\nfrom . import youtube_dl\\n\\nlogger = logging.getLogger(__name__)\\nrouter = Router()\\n\\n\\ndef youtube_url_filter(message: Message) -> bool:\\n    \"\"\"Filter for YouTube URLs only.\"\"\"\\n    return bool(message.text and is_youtube_url(message.text.strip()))\\n\\n\\nasync def send_initial_status(message: Message) -> Message:\\n    \"\"\"Send initial processing status message.\"\"\"\\n    return await message.reply(\"\u23f3 Processing YouTube link...\")\\n\\n\\nasync def update_status(status_msg: Message, text: str):\\n    \"\"\"Update status message with error handling.\"\"\"\\n    try:\\n        await status_msg.edit_text(text)\\n    except Exception as e:\\n        logger.debug(f\"Failed to update status: {e}\")\\n\\n\\n@router.message(youtube_url_filter)\\nasync def youtube_url_handler(message: Message, state: FSMContext):\\n    \"\"\"Handle YouTube URL.\"\"\"\\n    user_id = message.from_user.id\\n    url = message.text.strip()\\n\\n    # Log user action\\n    user_logger.log_user_action(\\n        \"youtube_url_handler\",\\n        user_id,\\n        \"YouTube URL received\",\\n        f\"URL: {url[:50]}...\"\\n    )\\n\\n    # Send initial status message\\n    status_msg = await send_initial_status(message)\\n\\n    try:\\n        # Get video info with timeout\\n        try:\\n            user_logger.log_user_action(\\n                \"youtube_url_handler\",\\n                user_id,\\n                \"Fetching YouTube video info\"\\n            )\\n\\n            video_info = await asyncio.wait_for(\\n                youtube_dl.get_video_info(url),\\n                timeout=30  # 30 second timeout\\n            )\\n        except asyncio.TimeoutError:\\n            user_logger.log_user_error(\\n                \"youtube_url_handler\",\\n                user_id,\\n                \"Timeout getting YouTube info\"\\n            )\\n            await update_status(\\n                status_msg,\\n                \"\u274c Timeout getting video info.\\n\"\\n                \"YouTube might be slow or the video is too large.\"\\n            )\\n            await state.clear()\\n            return\\n        except Exception as e:\\n            user_logger.log_user_error(\\n                \"youtube_url_handler\",\\n                user_id,\\n                f\"YouTube API error: {str(e)}\"\\n            )\\n            await update_status(\\n                status_msg,\\n                \"\u274c Error getting video info.\\n\"\\n                \"Please check the URL and try again.\"\\n            )\\n            await state.clear()\\n            return\\n\\n        # Check if anything is available\\n        qualities_with_size = video_info.get('qualities_with_size', [])\\n        audio_under_limit = video_info.get('audio_under_limit', False)\\n\\n        if not qualities_with_size and not audio_under_limit:\\n            max_size_mb = settings.MAX_FILE_SIZE / (1024 * 1024)\\n\\n            user_logger.log_user_action(\\n                \"youtube_url_handler\",\\n                user_id,\\n                \"No suitable formats available\",\\n                f\"Title: {video_info.get('title', 'Unknown')[:50]} | Limit: {max_size_mb:.0f}MB\"\\n            )\\n\\n            await update_status(\\n                status_msg,\\n                f\"\u274c <b>Unable to download</b>\\n\\n\"\\n                f\"\ud83d\udcf9 {video_info['title']}\\n\"\\n                f\"\u23f1 Duration: {video_info['duration']}\\n\\n\"\\n                f\"All formats exceed {max_size_mb:.0f} MB limit.\"\\n            )\\n            await state.clear()\\n            return\\n\\n        # Log video info retrieval\\n        user_logger.log_user_action(\\n            \"youtube_url_handler\",\\n            user_id,\\n            \"YouTube info retrieved\",\\n            f\"Title: {video_info.get('title', 'Unknown')[:50]} | \"\\n            f\"Author: {video_info.get('author', 'Unknown')[:30]} | \"\\n            f\"Qualities: {len(qualities_with_size)} | \"\\n            f\"Audio available: {audio_under_limit}\"\\n        )\\n\\n        # Prepare thumbnail asynchronously\\n        thumbnail = video_info.get('thumbnail')\\n        thumbnail_file = None\\n        if thumbnail:\\n            try:\\n                # Use URLInputFile without preloading\\n                thumbnail_file = URLInputFile(\\n                    thumbnail,\\n                    filename=\"thumbnail.jpg\"\\n                )\\n            except Exception as e:\\n                logger.warning(f\"Could not load thumbnail: {e}\")\\n\\n        # Create keyboard\\n        keyboard = get_quality_keyboard_with_sizes(\\n            qualities_with_size,\\n            audio_under_limit,\\n            video_info.get('audio_size_str')\\n        )\\n\\n        # Prepare caption\\n        title = video_info.get('title', 'Unknown Title')\\n        author = video_info.get('author', 'Unknown Author')\\n        duration = video_info.get('duration', 'Unknown')\\n\\n        caption = (\\n            f\"\ud83d\udcf9 <b>{title[:100]}{'...' if len(title) > 100 else ''}</b>\\n\"\\n            f\"\ud83d\udc64 {author[:50]}\\n\"\\n            f\"\u23f1 Duration: {duration}\\n\\n\"\\n            f\"\ud83d\udcbe Select quality to download:\"\\n        )\\n\\n        # Send options and delete status message\\n        try:\\n            if thumbnail_file:\\n                options_msg = await message.reply_photo(\\n                    photo=thumbnail_file,\\n                    caption=caption,\\n                    reply_markup=keyboard,\\n                    parse_mode=\"HTML\"\\n                )\\n            else:\\n                options_msg = await message.reply(\\n                    caption,\\n                    reply_markup=keyboard,\\n                    parse_mode=\"HTML\"\\n                )\\n        except Exception as e:\\n            logger.error(f\"Failed to send options: {e}\")\\n            # Fallback without thumbnail\\n            options_msg = await message.reply(\\n                caption,\\n                reply_markup=keyboard,\\n                parse_mode=\"HTML\"\\n            )\\n\\n        # Store in state WITH TIMESTAMP\\n        await state.update_data(\\n            video_info=video_info,\\n            url=url,\\n            platform=\"youtube\",\\n            timestamp=time.time(),\\n            options_message_id=options_msg.message_id,\\n            user_id=user_id  # Store user_id in state too\\n        )\\n        await state.set_state(YouTubeState.selecting_quality)\\n\\n        # Delete status message\\n        try:\\n            await status_msg.delete()\\n        except:\\n            pass\\n\\n        logger.info(f\"YouTube options sent for: {title[:50]}\")\\n\\n        # Log options sent\\n        user_logger.log_user_action(\\n            \"youtube_url_handler\",\\n            user_id,\\n            \"YouTube options sent to user\",\\n            f\"Message ID: {options_msg.message_id}\"\\n        )\\n\\n    except Exception as e:\\n        user_logger.log_user_error(\\n            \"youtube_url_handler\",\\n            user_id,\\n            f\"YouTube handler error: {str(e)}\"\\n        )\\n        try:\\n            await status_msg.edit_text(\\n                \"\u274c Unexpected error. Please try again.\"\\n            )\\n        except:\\n            await message.reply(\\n                \"\u274c Unexpected error. Please try again.\"\\n            )\\n        await state.clear()"
                                            },
                                            {
                                                "type": "file",
                                                "name": "__init__.py",
                                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\handlers\\youtube\\__init__.py",
                                                "size_bytes": 463,
                                                "content": "from aiogram import Router\\nfrom app.config.settings import settings\\nfrom app.downloader.youtube import YouTubeDownloader\\n\\n# Shared downloader instance\\nyoutube_dl = YouTubeDownloader(\\n    max_file_size=settings.MAX_FILE_SIZE,\\n    is_premium=settings.PREMIUM\\n)\\n\\nfrom .url_handler import router as url_router\\nfrom .callbacks import router as callbacks_router\\n\\nrouter = Router()\\nrouter.include_router(url_router)\\nrouter.include_router(callbacks_router)"
                                            },
                                            {
                                                "type": "directory",
                                                "name": "__pycache__",
                                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\handlers\\youtube\\__pycache__",
                                                "children": []
                                            }
                                        ]
                                    },
                                    {
                                        "type": "file",
                                        "name": "__init__.py",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\handlers\\__init__.py",
                                        "size_bytes": 373,
                                        "content": "from aiogram import Router\\nfrom .common import router as common_router\\nfrom .youtube import router as youtube_router\\nfrom .tiktok import router as tiktok_router\\n\\n# Create main router and include all sub-routers\\nrouter = Router()\\nrouter.include_router(common_router)\\nrouter.include_router(youtube_router)\\nrouter.include_router(tiktok_router)\\n\\n__all__ = ['router']"
                                    },
                                    {
                                        "type": "directory",
                                        "name": "__pycache__",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\handlers\\__pycache__",
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "type": "directory",
                                "name": "keyboards",
                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\keyboards",
                                "children": [
                                    {
                                        "type": "file",
                                        "name": "tiktok_kb.py",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\keyboards\\tiktok_kb.py",
                                        "size_bytes": 376,
                                        "content": "from aiogram.types import InlineKeyboardMarkup\\nfrom aiogram.utils.keyboard import InlineKeyboardBuilder\\n\\n\\ndef get_audio_button() -> InlineKeyboardMarkup:\\n    \"\"\"Create audio extraction button for TikTok videos.\"\"\"\\n    builder = InlineKeyboardBuilder()\\n    builder.button(text=\"\ud83c\udfb5 Extract Audio\", callback_data=\"tiktok_extract_audio\")\\n    return builder.as_markup()\\n"
                                    },
                                    {
                                        "type": "file",
                                        "name": "youtube_kb.py",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\keyboards\\youtube_kb.py",
                                        "size_bytes": 1327,
                                        "content": "from aiogram.types import InlineKeyboardMarkup\\nfrom aiogram.utils.keyboard import InlineKeyboardBuilder\\n\\n\\ndef get_quality_keyboard_with_sizes(\\n        qualities_with_size: list,\\n        audio_under_limit: bool = True,\\n        audio_size_str: str = \"\"\\n) -> InlineKeyboardMarkup:\\n    \"\"\"Create quality selection keyboard with file sizes.\"\"\"\\n    builder = InlineKeyboardBuilder()\\n\\n    # Reverse order so lowest quality is at top\\n    reversed_qualities = list(reversed(qualities_with_size))\\n\\n    # Add quality buttons with file sizes (2 per row)\\n    for height, size_bytes, size_str, estimated in reversed_qualities:\\n        display_text = f\"{height}p - {size_str}\"\\n        builder.button(\\n            text=display_text,\\n            callback_data=f\"quality_{height}\"\\n        )\\n\\n    # Calculate how many rows we need for qualities\\n    num_qualities = len(reversed_qualities)\\n\\n    # Add MP3 option at bottom if audio is under limit\\n    if audio_under_limit:\\n        builder.button(text=f\"\ud83c\udfb5 MP3 - {audio_size_str}\", callback_data=\"format_audio\")\\n\\n    # Adjust layout\\n    row_pattern = [2] * (num_qualities // 2)\\n    if num_qualities % 2 == 1:\\n        row_pattern.append(1)\\n    if audio_under_limit:\\n        row_pattern.append(1)\\n\\n    builder.adjust(*row_pattern)\\n    return builder.as_markup()"
                                    },
                                    {
                                        "type": "file",
                                        "name": "__init__.py",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\keyboards\\__init__.py",
                                        "size_bytes": 0,
                                        "content": ""
                                    },
                                    {
                                        "type": "directory",
                                        "name": "__pycache__",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\keyboards\\__pycache__",
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "type": "directory",
                                "name": "logs",
                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\logs",
                                "children": []
                            },
                            {
                                "type": "file",
                                "name": "main.py",
                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\main.py",
                                "size_bytes": 2668,
                                "content": "import sys\\nimport asyncio\\nimport logging\\nfrom aiogram import Bot, Dispatcher\\nfrom aiogram.client.default import DefaultBotProperties\\nfrom aiogram.enums import ParseMode\\n\\nfrom app.config.settings import settings\\nfrom app.bot.handlers import router\\nfrom app.bot.middlewares.throttling import ThrottlingMiddleware\\n\\n# Custom formatter to include user_id when available\\n# Custom formatter to include user_id when available\\nclass UserAwareFormatter(logging.Formatter):\\n    def format(self, record):\\n        # Try to extract user_id from extra dict\\n        user_id = getattr(record, 'user_id', None)\\n\\n        # Format the message normally first\\n        message = super().format(record)\\n\\n        # Remove ALL occurrences of [User:XXX] and \"User: XXX\" patterns from the message\\n        import re\\n        # Remove [User:XXX] patterns\\n        message = re.sub(r'\\[User:\\d+\\]\\s*', '', message)\\n        # Remove \"User: XXX\" patterns (with or without brackets)\\n        message = re.sub(r'User:\\s*\\d+\\s*[\\|]?\\s*', '', message)\\n        # Remove \"| User: XXX\" patterns\\n        message = re.sub(r'\\|\\s*User:\\s*\\d+', '', message)\\n\\n        # Clean up any double pipes or trailing/leading spaces\\n        message = re.sub(r'\\s*\\|\\s*\\|', ' |', message)  # Fix double pipes\\n        message = re.sub(r'\\s*\\|\\s*$', '', message)  # Remove trailing pipe\\n        message = message.strip()\\n\\n        # Add clean user ID at the beginning if available\\n        if user_id:\\n            message = f\"[User:{user_id}] {message}\"\\n\\n        return message\\n\\n# Configure logging\\nlogger = logging.getLogger(__name__)\\n\\n# Create formatter\\nformatter = UserAwareFormatter(\\n    \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\\n)\\n\\n# Create handlers\\nfile_handler = logging.FileHandler(f\"{settings.LOGS_DIR}/bot.log\", encoding='utf-8')\\nfile_handler.setFormatter(formatter)\\n\\nstream_handler = logging.StreamHandler(sys.stdout)\\nstream_handler.setFormatter(formatter)\\n\\n# Configure root logger\\nlogging.basicConfig(\\n    level=getattr(logging, settings.LOG_LEVEL),\\n    handlers=[file_handler, stream_handler]\\n)\\n\\n\\nasync def main():\\n    \"\"\"Start the bot.\"\"\"\\n    # Create bot\\n    bot = Bot(\\n        token=settings.BOT_TOKEN,\\n        default=DefaultBotProperties(parse_mode=ParseMode.HTML)\\n    )\\n    dp = Dispatcher()\\n\\n    # Setup middleware\\n    dp.message.middleware(ThrottlingMiddleware())\\n    dp.callback_query.middleware(ThrottlingMiddleware())\\n\\n    # Include router\\n    dp.include_router(router)\\n\\n    # Start bot\\n    logger.info(\"Bot is starting...\")\\n    await dp.start_polling(bot)\\n\\n\\nif __name__ == \"__main__\":\\n    asyncio.run(main())"
                            },
                            {
                                "type": "directory",
                                "name": "middlewares",
                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\middlewares",
                                "children": [
                                    {
                                        "type": "file",
                                        "name": "throttling.py",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\middlewares\\throttling.py",
                                        "size_bytes": 1620,
                                        "content": "import asyncio\\nfrom datetime import datetime, timedelta\\nfrom aiogram import BaseMiddleware\\nfrom aiogram.types import Message, CallbackQuery\\nfrom typing import Dict, Any, Callable, Awaitable\\n\\n\\nclass ThrottlingMiddleware(BaseMiddleware):\\n    \"\"\"Middleware for throttling requests.\"\"\"\\n\\n    def __init__(self, rate_limit: int = 1, period: int = 1):\\n        self.rate_limit = rate_limit\\n        self.period = period\\n        self.users: Dict[int, list] = {}\\n\\n    async def __call__(\\n            self,\\n            handler: Callable[[Message | CallbackQuery, Dict[str, Any]], Awaitable[Any]],\\n            event: Message | CallbackQuery,\\n            data: Dict[str, Any]\\n    ) -> Any:\\n        user_id = event.from_user.id\\n        current_time = datetime.now()\\n\\n        # Clean old timestamps\\n        if user_id in self.users:\\n            self.users[user_id] = [\\n                ts for ts in self.users[user_id]\\n                if current_time - ts < timedelta(seconds=self.period)\\n            ]\\n\\n        # Initialize user if not exists\\n        if user_id not in self.users:\\n            self.users[user_id] = []\\n\\n        # Check rate limit\\n        if len(self.users[user_id]) >= self.rate_limit:\\n            if isinstance(event, Message):\\n                await event.answer(\"\u23f3 Please wait before sending another request.\")\\n            else:\\n                await event.answer(\"\u23f3 Please wait...\", show_alert=True)\\n            return\\n\\n        # Add current timestamp\\n        self.users[user_id].append(current_time)\\n\\n        # Call handler\\n        return await handler(event, data)"
                                    },
                                    {
                                        "type": "file",
                                        "name": "__init__.py",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\middlewares\\__init__.py",
                                        "size_bytes": 0,
                                        "content": ""
                                    },
                                    {
                                        "type": "directory",
                                        "name": "__pycache__",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\middlewares\\__pycache__",
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "type": "directory",
                                "name": "states",
                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\states",
                                "children": [
                                    {
                                        "type": "file",
                                        "name": "download_states.py",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\states\\download_states.py",
                                        "size_bytes": 325,
                                        "content": "from aiogram.fsm.state import State, StatesGroup\\n\\n\\nclass YouTubeState(StatesGroup):\\n    \"\"\"YouTube specific states.\"\"\"\\n    selecting_quality = State()\\n    downloading_video = State()\\n    downloading_audio = State()\\n\\n\\nclass TikTokState(StatesGroup):\\n    \"\"\"TikTok specific states.\"\"\"\\n    selecting_format = State()"
                                    },
                                    {
                                        "type": "file",
                                        "name": "__init__.py",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\states\\__init__.py",
                                        "size_bytes": 0,
                                        "content": ""
                                    },
                                    {
                                        "type": "directory",
                                        "name": "__pycache__",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\states\\__pycache__",
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "type": "directory",
                                "name": "utils",
                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\utils",
                                "children": [
                                    {
                                        "type": "file",
                                        "name": "logger.py",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\utils\\logger.py",
                                        "size_bytes": 2270,
                                        "content": "import logging\\nfrom typing import Optional, Dict, Any\\n\\nlogger = logging.getLogger(__name__)\\n\\n\\nclass UserLogger:\\n    \"\"\"Logger with user context.\"\"\"\\n\\n    @staticmethod\\n    def log_user_action(\\n            function_name: str,\\n            user_id: int,\\n            action: str,\\n            details: str = \"\",\\n            extra: Optional[Dict[str, Any]] = None\\n    ):\\n        \"\"\"Log user actions with context.\"\"\"\\n        message = f\"[{function_name}] {action}\"\\n        if details:\\n            message += f\" | {details}\"\\n\\n        extra_data = extra or {}\\n        extra_data['user_id'] = user_id\\n\\n        logger.info(message, extra=extra_data)\\n\\n    @staticmethod\\n    def log_user_error(\\n            function_name: str,\\n            user_id: int,\\n            error_message: str,\\n            exc_info: bool = True,\\n            extra: Optional[Dict[str, Any]] = None\\n    ):\\n        \"\"\"Log user-related errors.\"\"\"\\n        message = f\"[{function_name}] ERROR: {error_message}\"\\n\\n        extra_data = extra or {}\\n        extra_data['user_id'] = user_id\\n\\n        logger.error(message, extra=extra_data, exc_info=exc_info)\\n\\n    @staticmethod\\n    def log_download_start(\\n            platform: str,\\n            user_id: int,\\n            url: str,\\n            quality: Optional[str] = None\\n    ):\\n        \"\"\"Log download start.\"\"\"\\n        message = f\"DOWNLOAD START | Platform: {platform}\"\\n        if quality:\\n            message += f\" | Quality: {quality}\"\\n\\n        # Store URL in extra, not in message\\n        logger.info(message, extra={\\n            'user_id': user_id,\\n            'url': url[:100],\\n            'quality': quality\\n        })\\n\\n    @staticmethod\\n    def log_download_complete(\\n            platform: str,\\n            user_id: int,\\n            file_size_mb: float,\\n            success: bool = True\\n    ):\\n        \"\"\"Log download completion.\"\"\"\\n        status = \"SUCCESS\" if success else \"FAILED\"\\n        message = f\"DOWNLOAD {status} | Platform: {platform} | Size: {file_size_mb:.1f}MB\"\\n\\n        logger.info(message, extra={\\n            'user_id': user_id,\\n            'file_size_mb': file_size_mb,\\n            'success': success\\n        })\\n\\n\\n# Convenience instance\\nuser_logger = UserLogger()"
                                    },
                                    {
                                        "type": "file",
                                        "name": "progress.py",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\utils\\progress.py",
                                        "size_bytes": 937,
                                        "content": "def create_video_progress_bar(percent: float) -> str:\\n    \"\"\"Create a visual progress bar with boxes.\"\"\"\\n    filled_boxes = int(percent / 10)  # 10 boxes total, each = 10%\\n    empty_boxes = 10 - filled_boxes\\n\\n    bar = \"\u2b1c\" * filled_boxes + \"\u2b1b\" * empty_boxes\\n    return f\"{bar} {percent:.0f}%\"\\n\\n\\n\\ndef format_file_size(size_bytes: int) -> str:\\n    \"\"\"Format file size to human readable format.\"\"\"\\n    for unit in ['B', 'KB', 'MB', 'GB']:\\n        if size_bytes < 1024.0:\\n            return f\"{size_bytes:.1f} {unit}\"\\n        size_bytes /= 1024.0\\n    return f\"{size_bytes:.1f} TB\"\\n\\n\\ndef format_duration(seconds: int) -> str:\\n    \"\"\"Format seconds to readable time.\"\"\"\\n    if not seconds:\\n        return 'Unknown'\\n\\n    hours = seconds // 3600\\n    minutes = (seconds % 3600) // 60\\n    secs = seconds % 60\\n\\n    if hours > 0:\\n        return f\"{hours}:{minutes:02d}:{secs:02d}\"\\n    return f\"{minutes}:{secs:02d}\""
                                    },
                                    {
                                        "type": "file",
                                        "name": "validators.py",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\utils\\validators.py",
                                        "size_bytes": 791,
                                        "content": "import re\\n\\n\\ndef is_youtube_url(url: str) -> bool:\\n    \"\"\"Check if URL is YouTube.\"\"\"\\n    youtube_patterns = [\\n        r'^(https?://)?(www\\.)?(youtube\\.com|youtu\\.be)/',\\n        r'^(https?://)?(m\\.)?youtube\\.com/',\\n        r'^(https?://)?(music\\.)?youtube\\.com/'\\n    ]\\n\\n    for pattern in youtube_patterns:\\n        if re.match(pattern, url, re.IGNORECASE):\\n            return True\\n    return False\\n\\n\\ndef is_tiktok_url(url: str) -> bool:\\n    \"\"\"Check if URL is TikTok.\"\"\"\\n    tiktok_patterns = [\\n        r'^(https?://)?(www\\.)?tiktok\\.com/',\\n        r'^(https?://)?(vm|vt)\\.tiktok\\.com/',\\n        r'^(https?://)?(m\\.)?tiktok\\.com/'\\n    ]\\n\\n    for pattern in tiktok_patterns:\\n        if re.match(pattern, url, re.IGNORECASE):\\n            return True\\n    return False"
                                    },
                                    {
                                        "type": "file",
                                        "name": "__init__.py",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\utils\\__init__.py",
                                        "size_bytes": 0,
                                        "content": ""
                                    },
                                    {
                                        "type": "directory",
                                        "name": "__pycache__",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\utils\\__pycache__",
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "type": "directory",
                                "name": "__pycache__",
                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\bot\\__pycache__",
                                "children": []
                            }
                        ]
                    },
                    {
                        "type": "directory",
                        "name": "config",
                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\config",
                        "children": [
                            {
                                "type": "file",
                                "name": "constants.py",
                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\config\\constants.py",
                                "size_bytes": 1675,
                                "content": "class Emojis:\\n    \"\"\"Emoji constants.\"\"\"\\n    VIDEO = \"\ud83c\udfac\"\\n    MUSIC = \"\ud83c\udfb5\"\\n    PHOTO = \"\ud83d\udcf8\"\\n    DOWNLOAD = \"\u2b07\ufe0f\"\\n    CHECK = \"\u2705\"\\n    CROSS = \"\u274c\"\\n    WARNING = \"\u26a0\ufe0f\"\\n    INFO = \"\u2139\ufe0f\"\\n    GEAR = \"\u2699\ufe0f\"\\n    CLOCK = \"\u23f1\"\\n    USER = \"\ud83d\udc64\"\\n    FOLDER = \"\ud83d\udcc1\"\\n    SIZE = \"\ud83d\udcbe\"\\n    QUALITY = \"\ud83d\udcfa\"\\n    HELP = \"\ud83d\udccb\"\\n    LIGHT = \"\ud83d\udca1\"\\n    THUMB_UP = \"\ud83d\udc4d\"\\n    THUMB_DOWN = \"\ud83d\udc4e\"\\n    PROGRESS = \"\ud83d\udcca\"\\n    LINK = \"\ud83d\udd17\"\\n    MAGNIFY = \"\ud83d\udd0d\"\\n    ROBOT = \"\ud83e\udd16\"\\n\\n\\nclass Messages:\\n    \"\"\"Message templates.\"\"\"\\n    START = (\\n        \"{video} <b>Video Downloader Bot</b>\\n\\n\"\\n        \"Send me a YouTube or TikTok URL to download!\\n\\n\"\\n        \"{light} <b>Features:</b>\\n\"\\n        \"\u2022 Choose video quality\\n\"\\n        \"\u2022 Download audio only (MP3)\\n\"\\n        \"\u2022 Real-time download progress\\n\"\\n        \"\u2022 Automatic cleanup\\n\\n\"\\n        \"{gear} <b>Mode:</b> {status}\"\\n    )\\n\\n    HELP = (\\n        \"{help} <b>How to use:</b>\\n\"\\n        \"1. Send YouTube or TikTok URL\\n\"\\n        \"2. Choose video quality or audio format\\n\"\\n        \"3. Wait for download (you'll see progress)\\n\"\\n        \"4. Receive your file!\\n\\n\"\\n        \"{light} <b>Tips:</b>\\n\"\\n        \"\u2022 {limit_text}\\n\"\\n        \"\u2022 Audio files are usually smaller\\n\"\\n        \"\u2022 Files are auto-deleted after sending\\n\\n\"\\n        \"<i>Supported: YouTube, TikTok</i>\"\\n    )\\n\\n    ERROR_INVALID_URL = (\\n        \"{cross} Please send a valid YouTube or TikTok URL.\\n\\n\"\\n        \"{light} <b>Examples:</b>\\n\"\\n        \"\u2022 https://www.youtube.com/watch?v=...\\n\"\\n        \"\u2022 https://youtu.be/...\\n\"\\n        \"\u2022 https://www.tiktok.com/@.../video/...\"\\n    )"
                            },
                            {
                                "type": "file",
                                "name": "settings.py",
                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\config\\settings.py",
                                "size_bytes": 965,
                                "content": "import os\\nfrom dotenv import load_dotenv\\n\\nload_dotenv()\\n\\n\\nclass Settings:\\n    \"\"\"Application settings.\"\"\"\\n\\n    # Bot\\n    BOT_TOKEN = os.getenv(\"BOT_TOKEN\")\\n    if not BOT_TOKEN:\\n        raise ValueError(\"BOT_TOKEN is required in .env file\")\\n\\n    # Premium mode\\n    PREMIUM = os.getenv(\"PREMIUM\", \"False\").lower() in ('true', '1', 'yes')\\n\\n    # File size limits\\n    if PREMIUM:\\n        MAX_FILE_SIZE = 2 * 1024 * 1024 * 1024  # 2GB for premium\\n    else:\\n        MAX_FILE_SIZE = 50 * 1024 * 1024  # 50MB for regular users\\n\\n    # Directories\\n    TEMP_DIR = \"temp\"\\n    LOGS_DIR = \"logs\"\\n\\n    # Logging\\n    LOG_LEVEL = os.getenv(\"LOG_LEVEL\", \"INFO\")\\n\\n    # Create directories\\n    os.makedirs(TEMP_DIR, exist_ok=True)\\n    os.makedirs(LOGS_DIR, exist_ok=True)\\n\\n    # Download settings\\n    MAX_DOWNLOAD_RETRIES = 3\\n    DOWNLOAD_TIMEOUT = 300  # 5 minutes\\n\\n    # Cache settings\\n    CACHE_TTL = 3600  # 1 hour\\n\\n\\nsettings = Settings()"
                            },
                            {
                                "type": "file",
                                "name": "__init__.py",
                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\config\\__init__.py",
                                "size_bytes": 0,
                                "content": ""
                            },
                            {
                                "type": "directory",
                                "name": "__pycache__",
                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\config\\__pycache__",
                                "children": []
                            }
                        ]
                    },
                    {
                        "type": "directory",
                        "name": "core",
                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\core",
                        "children": [
                            {
                                "type": "file",
                                "name": "file_manager.py",
                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\core\\file_manager.py",
                                "size_bytes": 7484,
                                "content": "\"\"\"\\nFile management utilities for the application.\\n\"\"\"\\nimport os\\nimport asyncio\\nimport logging\\nimport subprocess\\nimport shutil\\nfrom pathlib import Path\\nfrom typing import Optional, List, Tuple\\nimport uuid\\nimport time\\n\\nfrom app.config.settings import settings\\n\\nlogger = logging.getLogger(__name__)\\n\\n\\nclass FileManager:\\n    \"\"\"Manages file operations for the application.\"\"\"\\n\\n    def __init__(self):\\n        self.temp_dir = settings.TEMP_DIR\\n        self.ensure_temp_dir()\\n\\n    def ensure_temp_dir(self) -> None:\\n        \"\"\"Ensure temp directory exists.\"\"\"\\n        os.makedirs(self.temp_dir, exist_ok=True)\\n        logger.debug(f\"Temp directory ensured: {self.temp_dir}\")\\n\\n    async def extract_audio_from_video(self, video_path: str) -> str:\\n        \"\"\"Extract audio from video file and return audio file path.\"\"\"\\n        try:\\n            if not os.path.exists(video_path):\\n                raise FileNotFoundError(f\"Video file not found: {video_path}\")\\n\\n            # Generate output filename\\n            video_name = Path(video_path).stem\\n            audio_path = os.path.join(self.temp_dir, f\"{video_name}_audio.mp3\")\\n\\n            # Use ffmpeg to extract audio\\n            cmd = [\\n                'ffmpeg',\\n                '-i', video_path,\\n                '-q:a', '0',\\n                '-map', 'a',\\n                audio_path,\\n                '-y'  # Overwrite if exists\\n            ]\\n\\n            # Run ffmpeg in executor\\n            loop = asyncio.get_event_loop()\\n            process = await loop.run_in_executor(\\n                None,\\n                lambda: subprocess.run(cmd, capture_output=True, text=True)\\n            )\\n\\n            if process.returncode != 0:\\n                raise Exception(f\"FFmpeg error: {process.stderr}\")\\n\\n            if not os.path.exists(audio_path):\\n                raise Exception(\"Audio extraction failed - no output file\")\\n\\n            logger.info(f\"Audio extracted: {audio_path}\")\\n            return audio_path\\n\\n        except Exception as e:\\n            logger.error(f\"Audio extraction error: {e}\")\\n            raise\\n\\n    async def cleanup_file(self, file_path: str) -> bool:\\n        \"\"\"Clean up a file. Returns True if successful.\"\"\"\\n        try:\\n            if os.path.exists(file_path):\\n                os.remove(file_path)\\n                logger.debug(f\"Cleaned up file: {file_path}\")\\n                return True\\n        except Exception as e:\\n            logger.warning(f\"Failed to cleanup file {file_path}: {e}\")\\n        return False\\n\\n    async def cleanup_files(self, file_paths: List[str]) -> int:\\n        \"\"\"Clean up multiple files. Returns number of successfully deleted files.\"\"\"\\n        deleted = 0\\n        for file_path in file_paths:\\n            if await self.cleanup_file(file_path):\\n                deleted += 1\\n        return deleted\\n\\n    async def get_file_size(self, file_path: str) -> int:\\n        \"\"\"Get file size in bytes.\"\"\"\\n        try:\\n            return os.path.getsize(file_path)\\n        except OSError:\\n            return 0\\n\\n    async def get_file_size_mb(self, file_path: str) -> float:\\n        \"\"\"Get file size in MB.\"\"\"\\n        size_bytes = await self.get_file_size(file_path)\\n        return size_bytes / (1024 * 1024)\\n\\n    async def is_file_too_large(self, file_path: str, max_size: Optional[int] = None) -> bool:\\n        \"\"\"Check if file exceeds maximum size.\"\"\"\\n        if max_size is None:\\n            max_size = settings.MAX_FILE_SIZE\\n\\n        size = await self.get_file_size(file_path)\\n        return size > max_size\\n\\n    def create_temp_filename(self, prefix: str = \"file\", extension: str = \"mp4\") -> str:\\n        \"\"\"Create a unique temporary filename.\"\"\"\\n        timestamp = int(time.time())\\n        unique_id = str(uuid.uuid4())[:8]\\n        filename = f\"{prefix}_{timestamp}_{unique_id}.{extension}\"\\n        return os.path.join(self.temp_dir, filename)\\n\\n    async def convert_video_format(\\n            self,\\n            input_path: str,\\n            output_format: str = \"mp4\",\\n            codec: str = \"copy\"\\n    ) -> str:\\n        \"\"\"Convert video to different format.\"\"\"\\n        try:\\n            output_path = os.path.join(\\n                self.temp_dir,\\n                f\"{Path(input_path).stem}.{output_format}\"\\n            )\\n\\n            cmd = [\\n                'ffmpeg',\\n                '-i', input_path,\\n                '-c', codec,\\n                '-y',\\n                output_path\\n            ]\\n\\n            loop = asyncio.get_event_loop()\\n            process = await loop.run_in_executor(\\n                None,\\n                lambda: subprocess.run(cmd, capture_output=True, text=True)\\n            )\\n\\n            if process.returncode != 0:\\n                raise Exception(f\"FFmpeg conversion error: {process.stderr}\")\\n\\n            if not os.path.exists(output_path):\\n                raise Exception(\"Conversion failed - no output file\")\\n\\n            logger.info(f\"Video converted: {output_path}\")\\n            return output_path\\n\\n        except Exception as e:\\n            logger.error(f\"Video conversion error: {e}\")\\n            raise\\n\\n    async def get_temp_dir_size(self) -> Tuple[float, int]:\\n        \"\"\"\\n        Get temp directory size.\\n\\n        Returns:\\n            Tuple of (size_in_mb, file_count)\\n        \"\"\"\\n        total_size = 0\\n        file_count = 0\\n\\n        for dirpath, dirnames, filenames in os.walk(self.temp_dir):\\n            for filename in filenames:\\n                filepath = os.path.join(dirpath, filename)\\n                total_size += os.path.getsize(filepath)\\n                file_count += 1\\n\\n        return total_size / (1024 * 1024), file_count\\n\\n    async def cleanup_old_temp_files(self, max_age_hours: int = 24) -> int:\\n        \"\"\"\\n        Clean up temporary files older than specified hours.\\n\\n        Returns:\\n            Number of files deleted\\n        \"\"\"\\n        current_time = time.time()\\n        max_age_seconds = max_age_hours * 3600\\n        deleted = 0\\n\\n        for dirpath, dirnames, filenames in os.walk(self.temp_dir):\\n            for filename in filenames:\\n                filepath = os.path.join(dirpath, filename)\\n                try:\\n                    file_mtime = os.path.getmtime(filepath)\\n                    if current_time - file_mtime > max_age_seconds:\\n                        if await self.cleanup_file(filepath):\\n                            deleted += 1\\n                except OSError:\\n                    continue\\n\\n        if deleted > 0:\\n            logger.info(f\"Cleaned up {deleted} old temp files (> {max_age_hours} hours)\")\\n\\n        return deleted\\n\\n\\n# Global file manager instance\\nfile_manager = FileManager()\\n\\n\\n# Legacy async functions for backward compatibility\\nasync def extract_audio_from_video(video_path: str) -> str:\\n    return await file_manager.extract_audio_from_video(video_path)\\n\\n\\nasync def cleanup_file(file_path: str) -> bool:\\n    return await file_manager.cleanup_file(file_path)\\n\\n\\nasync def get_file_size(file_path: str) -> int:\\n    return await file_manager.get_file_size(file_path)\\n\\n\\nasync def is_file_too_large(file_path: str, max_size: Optional[int] = None) -> bool:\\n    return await file_manager.is_file_too_large(file_path, max_size)\\n\\n\\nasync def create_temp_filename(prefix: str = \"file\", extension: str = \"mp4\") -> str:\\n    return file_manager.create_temp_filename(prefix, extension)"
                            },
                            {
                                "type": "file",
                                "name": "__init__.py",
                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\core\\__init__.py",
                                "size_bytes": 0,
                                "content": ""
                            },
                            {
                                "type": "directory",
                                "name": "__pycache__",
                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\core\\__pycache__",
                                "children": []
                            }
                        ]
                    },
                    {
                        "type": "directory",
                        "name": "downloader",
                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\downloader",
                        "children": [
                            {
                                "type": "directory",
                                "name": "tiktok",
                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\downloader\\tiktok",
                                "children": [
                                    {
                                        "type": "file",
                                        "name": "audio_extractor.py",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\downloader\\tiktok\\audio_extractor.py",
                                        "size_bytes": 4559,
                                        "content": "import logging\\nfrom typing import Optional, Callable\\n\\nlogger = logging.getLogger(__name__)\\n\\n\\nclass TikTokAudioExtractor:\\n    \"\"\"Extract audio from TikTok videos/photos.\"\"\"\\n\\n    def __init__(self, temp_dir: str = \"temp\"):\\n        self.temp_dir = temp_dir\\n\\n    async def download(self, url: str, progress_callback: Optional[Callable] = None) -> str:\\n        \"\"\"Download TikTok audio only using yt-dlp directly.\"\"\"\\n        try:\\n            from .base_client import TikTokBaseClient\\n            from .ytdlp_client import TikTokVideoDownloader\\n\\n            base_client = TikTokBaseClient(self.temp_dir)\\n            video_downloader = TikTokVideoDownloader(self.temp_dir)\\n\\n            # Resolve URL and get info\\n            url = await base_client._resolve_url(url)\\n            username, video_id, content_type = base_client._extract_video_id(url)\\n\\n            logger.info(f\"TikTok audio download: user=@{username}, id={video_id}, type={content_type}\")\\n\\n            # For photo posts, we need to convert the URL to video format\\n            if content_type == \"photo\":\\n                # Convert photo URL to video URL for yt-dlp\\n                video_url = await base_client._convert_photo_to_video_url(url)\\n                logger.info(f\"Converted photo URL to video URL for audio extraction: {video_url}\")\\n\\n                # Try to download audio from the video URL\\n                result = await video_downloader.download(video_url, video_id, True, progress_callback)\\n            else:\\n                # For video posts, use the original URL\\n                result = await video_downloader.download(url, video_id, True, progress_callback)\\n\\n            if result:\\n                return result\\n            else:\\n                raise Exception(\"Failed to download audio via yt-dlp\")\\n\\n        except Exception as e:\\n            logger.error(f\"TikTok audio error: {e}\")\\n            # Try alternative method if yt-dlp fails\\n            logger.info(\"Trying alternative audio extraction method...\")\\n            return await self._download_audio_alternative(url, progress_callback)\\n\\n    async def _download_audio_alternative(self, url: str, progress_callback: Optional[Callable] = None) -> str:\\n        \"\"\"Alternative method to extract audio if yt-dlp fails.\"\"\"\\n        try:\\n            from .base_client import TikTokBaseClient\\n            from .ytdlp_client import TikTokVideoDownloader\\n            import os\\n            import asyncio\\n            import imageio_ffmpeg\\n\\n            base_client = TikTokBaseClient(self.temp_dir)\\n            video_downloader = TikTokVideoDownloader(self.temp_dir)\\n\\n            # Try to extract video first, then extract audio from it\\n            logger.info(\"Trying alternative: download video then extract audio...\")\\n\\n            # Download the video\\n            video_path = await video_downloader.download(url, \"temp_video\", False, progress_callback)\\n\\n            if isinstance(video_path, list):\\n                raise Exception(\"Cannot extract audio from photos directly\")\\n\\n            # Extract audio using ffmpeg\\n            ffmpeg_path = imageio_ffmpeg.get_ffmpeg_exe()\\n\\n            video_id = os.path.splitext(os.path.basename(video_path))[0]\\n            audio_path = os.path.join(self.temp_dir, f\"{video_id}_audio.mp3\")\\n\\n            # Update progress for audio extraction\\n            if progress_callback:\\n                await progress_callback(80)\\n\\n            # Run ffmpeg to extract audio\\n            process = await asyncio.create_subprocess_exec(\\n                ffmpeg_path,\\n                '-i', video_path,\\n                '-vn',\\n                '-acodec', 'libmp3lame',\\n                '-ab', '192k',\\n                '-y',\\n                audio_path,\\n                stdout=asyncio.subprocess.PIPE,\\n                stderr=asyncio.subprocess.PIPE\\n            )\\n            await process.wait()\\n\\n            # Clean up video file\\n            if os.path.exists(video_path):\\n                os.remove(video_path)\\n\\n            if progress_callback:\\n                await progress_callback(100)\\n\\n            if os.path.exists(audio_path):\\n                logger.info(f\"Audio extracted via alternative method: {audio_path}\")\\n                return audio_path\\n            else:\\n                raise Exception(\"Alternative audio extraction failed\")\\n\\n        except Exception as e:\\n            logger.error(f\"Alternative audio extraction error: {e}\")\\n            raise Exception(f\"Audio extraction failed: {str(e)}\")"
                                    },
                                    {
                                        "type": "file",
                                        "name": "base_client.py",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\downloader\\tiktok\\base_client.py",
                                        "size_bytes": 3586,
                                        "content": "import re\\nimport logging\\nimport aiohttp\\nfrom typing import Dict\\n\\nlogger = logging.getLogger(__name__)\\n\\nHEADERS = {\\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:126.0) Gecko/20100101 Firefox/126.0',\\n    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\\n    'Accept-Language': 'en-US,en;q=0.5',\\n    'Connection': 'keep-alive',\\n}\\n\\n\\nclass TikTokBaseClient:\\n    \"\"\"Base TikTok client for URL handling and info extraction.\"\"\"\\n\\n    def __init__(self, temp_dir: str = \"temp\"):\\n        self.temp_dir = temp_dir\\n\\n    def _extract_video_id(self, url: str) -> tuple:\\n        \"\"\"Extract username, video_id, and content_type from TikTok URL.\"\"\"\\n        username_pattern = r\"@([A-Za-z0-9_.]+)\"\\n        content_type_pattern = r\"/(video|photo)/(\\d+)\"\\n\\n        username_match = re.search(username_pattern, url)\\n        username = username_match.group(1) if username_match else \"unknown\"\\n\\n        content_type_match = re.search(content_type_pattern, url)\\n        if content_type_match:\\n            content_type = content_type_match.group(1)\\n            video_id = content_type_match.group(2)\\n        else:\\n            # Try to extract just the ID from the URL\\n            id_match = re.search(r'/(\\d{15,})/?', url)\\n            video_id = id_match.group(1) if id_match else \"unknown\"\\n            content_type = \"video\"\\n\\n        return username, video_id, content_type\\n\\n    async def _resolve_url(self, url: str) -> str:\\n        \"\"\"Resolve shortened URLs to full URLs.\"\"\"\\n        if 'vm.tiktok.com' in url or 'vt.tiktok.com' in url:\\n            async with aiohttp.ClientSession() as session:\\n                async with session.get(url, headers=HEADERS, allow_redirects=True) as response:\\n                    return str(response.url)\\n        return url\\n\\n    async def _convert_photo_to_video_url(self, photo_url: str) -> str:\\n        \"\"\"Convert TikTok photo URL to video URL.\"\"\"\\n        try:\\n            # Photo URL: https://www.tiktok.com/@username/photo/1234567890\\n            # Convert to: https://www.tiktok.com/@username/video/1234567890\\n            if '/photo/' in photo_url:\\n                video_url = photo_url.replace('/photo/', '/video/')\\n                logger.info(f\"Converted photo URL to video URL: {video_url}\")\\n                return video_url\\n            return photo_url\\n        except Exception as e:\\n            logger.error(f\"Failed to convert photo URL: {e}\")\\n            return photo_url\\n\\n    async def get_video_info(self, url: str) -> Dict:\\n        \"\"\"Get TikTok video/photo info.\"\"\"\\n        try:\\n            url = await self._resolve_url(url)\\n            username, video_id, content_type = self._extract_video_id(url)\\n\\n            is_slideshow = content_type == \"photo\"\\n\\n            title = f\"TikTok {'Photos' if is_slideshow else 'Video'} by @{username}\"\\n\\n            return {\\n                'title': title[:100],\\n                'author': username,\\n                'duration': 'Unknown',\\n                'video_id': video_id,\\n                'thumbnail': None,\\n                'is_slideshow': is_slideshow,\\n                'num_images': 0,  # Will be determined during download\\n                'image_urls': [],\\n                'has_audio': True,\\n                'content_type': content_type,\\n                'resolved_url': url,\\n                'video_url': await self._convert_photo_to_video_url(url) if is_slideshow else url,\\n            }\\n        except Exception as e:\\n            logger.error(f\"TikTok info error: {e}\")\\n            raise"
                                    },
                                    {
                                        "type": "file",
                                        "name": "musicaldown.py",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\downloader\\tiktok\\musicaldown.py",
                                        "size_bytes": 4090,
                                        "content": "import os\\nimport re\\nimport logging\\nimport aiohttp\\nfrom typing import List, Optional, Callable\\n\\nlogger = logging.getLogger(__name__)\\n\\nHEADERS = {\\n    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:126.0) Gecko/20100101 Firefox/126.0',\\n    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\\n    'Accept-Language': 'en-US,en;q=0.5',\\n    'Connection': 'keep-alive',\\n}\\n\\n\\nclass TikTokPhotoDownloader:\\n    \"\"\"Download TikTok photos using musicaldown.com API.\"\"\"\\n\\n    def __init__(self, temp_dir: str = \"temp\"):\\n        self.temp_dir = temp_dir\\n        os.makedirs(temp_dir, exist_ok=True)\\n\\n    async def download(self, url: str, video_id: str, progress_callback: Optional[Callable] = None) -> List[str]:\\n        \"\"\"Download PHOTOS using musicaldown.com API.\"\"\"\\n        headers = {\\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:126.0) Gecko/20100101 Firefox/126.0',\\n            'Content-Type': 'application/x-www-form-urlencoded',\\n            'Origin': 'https://musicaldown.com',\\n            'Referer': 'https://musicaldown.com/en?ref=more',\\n        }\\n\\n        async with aiohttp.ClientSession() as session:\\n            # Get the page to extract tokens\\n            async with session.get(\"https://musicaldown.com/en\", headers=headers) as response:\\n                html = await response.text()\\n\\n            # Extract tokens using regex\\n            token_a_match = re.search(r'<input\\s+name=\"([^\"]+)\"[^>]*id=\"link_url\"', html)\\n            if not token_a_match:\\n                token_a_match = re.search(r'name=\"([^\"]+)\"[^>]*id=\"link_url\"', html)\\n\\n            token_b_match = re.search(r'<input\\s+name=\"([^\"]+)\"\\s+type=\"hidden\"\\s+value=\"([^\"]*)\"', html)\\n\\n            if not token_a_match:\\n                raise Exception(\"Could not find token_a\")\\n\\n            token_a = token_a_match.group(1)\\n            token_b = token_b_match.group(1) if token_b_match else None\\n            token_b_value = token_b_match.group(2) if token_b_match else None\\n\\n            data = {token_a: url, 'verify': '1'}\\n            if token_b and token_b_value:\\n                data[token_b] = token_b_value\\n\\n            if progress_callback:\\n                await progress_callback(10)\\n\\n            # Submit the form\\n            async with session.post(\\n                    'https://musicaldown.com/download',\\n                    headers=headers,\\n                    data=data\\n            ) as response:\\n                result_html = await response.text()\\n\\n            if progress_callback:\\n                await progress_callback(30)\\n\\n            # Extract photo URLs\\n            photo_urls = re.findall(r'<div class=\"card-image\">\\s*<img[^>]+src=\"([^\"]+)\"', result_html)\\n\\n            if not photo_urls:\\n                # Try alternative pattern\\n                photo_urls = re.findall(r'class=\"card-image\"[^>]*>.*?<img[^>]+src=\"([^\"]+)\"', result_html, re.DOTALL)\\n\\n            if not photo_urls:\\n                raise Exception(\"No photo URLs found\")\\n\\n            logger.info(f\"Found {len(photo_urls)} photos\")\\n\\n            # Download all photos\\n            downloaded_files = []\\n            total = len(photo_urls)\\n\\n            for i, photo_url in enumerate(photo_urls):\\n                if progress_callback:\\n                    percent = 30 + ((i + 1) / total) * 60\\n                    await progress_callback(percent)\\n\\n                file_path = os.path.join(self.temp_dir, f\"{video_id}_photo_{i + 1}.jpeg\")\\n\\n                async with session.get(photo_url, headers=HEADERS) as img_response:\\n                    if img_response.status == 200:\\n                        content = await img_response.read()\\n                        with open(file_path, 'wb') as f:\\n                            f.write(content)\\n                        downloaded_files.append(file_path)\\n                        logger.debug(f\"Downloaded photo {i + 1}/{total}\")\\n\\n            if progress_callback:\\n                await progress_callback(100)\\n\\n            return downloaded_files"
                                    },
                                    {
                                        "type": "file",
                                        "name": "ytdlp_client.py",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\downloader\\tiktok\\ytdlp_client.py",
                                        "size_bytes": 7367,
                                        "content": "import os\\nimport logging\\nimport asyncio\\nimport yt_dlp\\nimport imageio_ffmpeg\\nfrom typing import Optional, Callable\\n\\nlogger = logging.getLogger(__name__)\\n\\n\\nclass TikTokVideoDownloader:\\n    \"\"\"Download TikTok videos using yt-dlp.\"\"\"\\n\\n    def __init__(self, temp_dir: str = \"temp\"):\\n        self.temp_dir = temp_dir\\n        os.makedirs(temp_dir, exist_ok=True)\\n\\n    async def download(self, url: str, video_id: str, extract_audio: bool = False,\\n                       progress_callback: Optional[Callable] = None) -> str:\\n        \"\"\"Download TikTok video or audio using yt-dlp.\"\"\"\\n        try:\\n            # Shared progress state between threads\\n            progress_state = {'percent': 0, 'downloading': True}\\n\\n            # Progress hook runs in the download thread\\n            def progress_hook(d):\\n                if d['status'] == 'downloading':\\n                    percent_str = d.get('_percent_str', '0%').strip('%')\\n                    try:\\n                        progress_state['percent'] = float(percent_str)\\n                    except:\\n                        pass\\n                elif d['status'] == 'finished':\\n                    progress_state['downloading'] = False\\n\\n            # Background task to update progress\\n            async def update_progress_loop():\\n                last_percent = -1\\n                while progress_state['downloading']:\\n                    current_percent = progress_state['percent']\\n                    # Only update if changed by at least 20% to reduce overhead\\n                    if abs(current_percent - last_percent) >= 20:\\n                        try:\\n                            await progress_callback(current_percent)\\n                            last_percent = current_percent\\n                        except Exception as e:\\n                            logger.debug(f\"Progress callback error: {e}\")\\n                    await asyncio.sleep(0.5)  # Check every 0.5 seconds\\n\\n            # Start progress updater if callback provided\\n            progress_task = None\\n            if progress_callback:\\n                progress_task = asyncio.create_task(update_progress_loop())\\n\\n            # Get ffmpeg path from imageio-ffmpeg\\n            ffmpeg_path = imageio_ffmpeg.get_ffmpeg_exe()\\n\\n            # yt-dlp options\\n            if extract_audio:\\n                # Download audio only\\n                ydl_opts = {\\n                    'format': 'bestaudio/best',\\n                    'outtmpl': os.path.join(self.temp_dir, '%(id)s_audio.%(ext)s'),\\n                    'quiet': True,\\n                    'no_warnings': True,\\n                    'ffmpeg_location': ffmpeg_path,\\n                    'postprocessors': [{\\n                        'key': 'FFmpegExtractAudio',\\n                        'preferredcodec': 'mp3',\\n                        'preferredquality': '192',\\n                    }],\\n                    'progress_hooks': [progress_hook],\\n                }\\n            else:\\n                # Download video\\n                ydl_opts = {\\n                    'format': 'best',\\n                    'outtmpl': os.path.join(self.temp_dir, '%(id)s.%(ext)s'),\\n                    'quiet': True,\\n                    'no_warnings': True,\\n                    'merge_output_format': 'mp4',\\n                    'ffmpeg_location': ffmpeg_path,\\n                    'progress_hooks': [progress_hook],\\n                }\\n\\n            logger.info(f\"Downloading TikTok {'audio' if extract_audio else 'video'} using yt-dlp: {url}\")\\n\\n            # Run download in executor\\n            loop = asyncio.get_event_loop()\\n\\n            def download_with_ydlp():\\n                with yt_dlp.YoutubeDL(ydl_opts) as ydl:\\n                    # Get info first to know video ID\\n                    info = ydl.extract_info(url, download=False)\\n                    video_id_from_info = info.get('id', 'tiktok')\\n\\n                    # Then download\\n                    ydl.download([url])\\n                    return video_id_from_info, info.get('extractor', 'tiktok')\\n\\n            downloaded_id, extractor = await loop.run_in_executor(None, download_with_ydlp)\\n\\n            # Mark download as complete and wait for progress task\\n            progress_state['downloading'] = False\\n            if progress_task:\\n                try:\\n                    await asyncio.wait_for(progress_task, timeout=1.0)\\n                except asyncio.TimeoutError:\\n                    progress_task.cancel()\\n\\n            # Find the downloaded file\\n            if extract_audio:\\n                # Look for audio files\\n                for file in os.listdir(self.temp_dir):\\n                    if downloaded_id in file and file.endswith('.mp3'):\\n                        file_path = os.path.join(self.temp_dir, file)\\n                        logger.info(f\"Downloaded TikTok audio: {file_path}\")\\n                        return file_path\\n\\n                # Also check for other audio extensions\\n                audio_extensions = ['.m4a', '.aac', '.opus', '.flac', '.wav']\\n                for ext in audio_extensions:\\n                    for file in os.listdir(self.temp_dir):\\n                        if downloaded_id in file and file.endswith(ext):\\n                            file_path = os.path.join(self.temp_dir, file)\\n                            logger.info(f\"Downloaded TikTok audio ({ext}): {file_path}\")\\n                            return file_path\\n            else:\\n                # Look for video files\\n                for file in os.listdir(self.temp_dir):\\n                    if downloaded_id in file and (\\n                            file.endswith('.mp4') or file.endswith('.mkv') or file.endswith('.webm')):\\n                        file_path = os.path.join(self.temp_dir, file)\\n\\n                        # If not mp4, convert to mp4\\n                        if not file.endswith('.mp4'):\\n                            mp4_path = os.path.join(self.temp_dir, f\"{downloaded_id}.mp4\")\\n                            await self._convert_to_mp4(file_path, mp4_path)\\n                            os.remove(file_path)\\n                            file_path = mp4_path\\n\\n                        logger.info(f\"Downloaded TikTok video: {file_path}\")\\n                        return file_path\\n\\n            raise Exception(f\"Downloaded file not found for TikTok\")\\n\\n        except Exception as e:\\n            logger.error(f\"yt-dlp TikTok download error: {e}\")\\n            raise\\n\\n    async def _convert_to_mp4(self, input_path: str, output_path: str):\\n        \"\"\"Convert video to mp4 format using ffmpeg.\"\"\"\\n        try:\\n            ffmpeg_path = imageio_ffmpeg.get_ffmpeg_exe()\\n\\n            process = await asyncio.create_subprocess_exec(\\n                ffmpeg_path,\\n                '-i', input_path,\\n                '-c', 'copy',  # Copy streams without re-encoding\\n                '-y',\\n                output_path,\\n                stdout=asyncio.subprocess.PIPE,\\n                stderr=asyncio.subprocess.PIPE\\n            )\\n            await process.wait()\\n\\n            if os.path.exists(output_path):\\n                return output_path\\n            else:\\n                raise Exception(\"Conversion failed\")\\n        except Exception as e:\\n            logger.error(f\"Conversion error: {e}\")\\n            raise"
                                    },
                                    {
                                        "type": "file",
                                        "name": "__init__.py",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\downloader\\tiktok\\__init__.py",
                                        "size_bytes": 1447,
                                        "content": "import os\\nimport logging\\nfrom .base_client import TikTokBaseClient\\nfrom .musicaldown import TikTokPhotoDownloader\\nfrom .ytdlp_client import TikTokVideoDownloader\\nfrom .audio_extractor import TikTokAudioExtractor\\n\\nlogger = logging.getLogger(__name__)\\n\\n\\nclass TikTokDownloader:\\n    \"\"\"Facade that combines all TikTok downloader components.\"\"\"\\n\\n    def __init__(self, temp_dir: str = \"temp\"):\\n        self.temp_dir = temp_dir\\n        os.makedirs(temp_dir, exist_ok=True)\\n        self.base = TikTokBaseClient(temp_dir)\\n        self.photos = TikTokPhotoDownloader(temp_dir)\\n        self.videos = TikTokVideoDownloader(temp_dir)\\n        self.audio = TikTokAudioExtractor(temp_dir)\\n\\n    async def get_video_info(self, url: str):\\n        \"\"\"Get TikTok video/photo info.\"\"\"\\n        return await self.base.get_video_info(url)\\n\\n    async def download_video(self, url: str, progress_callback=None):\\n        \"\"\"Download TikTok video or photos.\"\"\"\\n        info = await self.get_video_info(url)\\n\\n        if info.get('content_type') == \"photo\":\\n            return await self.photos.download(url, info.get('video_id'), progress_callback)\\n        else:\\n            return await self.videos.download(url, info.get('video_id'), False, progress_callback)\\n\\n    async def download_audio(self, url: str, progress_callback=None):\\n        \"\"\"Download TikTok audio only.\"\"\"\\n        return await self.audio.download(url, progress_callback)"
                                    },
                                    {
                                        "type": "directory",
                                        "name": "__pycache__",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\downloader\\tiktok\\__pycache__",
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "type": "directory",
                                "name": "youtube",
                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\downloader\\youtube",
                                "children": [
                                    {
                                        "type": "file",
                                        "name": "audio_downloader.py",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\downloader\\youtube\\audio_downloader.py",
                                        "size_bytes": 4469,
                                        "content": "import os\\nimport logging\\nimport asyncio\\nimport yt_dlp\\nimport imageio_ffmpeg\\nfrom typing import Optional, Callable\\n\\nlogger = logging.getLogger(__name__)\\n\\n\\nclass YouTubeAudioDownloader:\\n    \"\"\"Download YouTube audio.\"\"\"\\n\\n    def __init__(self, temp_dir: str = \"temp\"):\\n        self.temp_dir = temp_dir\\n        os.makedirs(temp_dir, exist_ok=True)\\n\\n    async def download(self, url: str, progress_callback: Optional[Callable] = None) -> str:\\n        \"\"\"Download audio only using yt-dlp with progress tracking.\"\"\"\\n        try:\\n            # Shared progress state between threads\\n            progress_state = {'percent': 0, 'downloading': True}\\n\\n            # Progress hook runs in the download thread\\n            def progress_hook(d):\\n                if d['status'] == 'downloading':\\n                    percent_str = d.get('_percent_str', '0%').strip('%')\\n                    try:\\n                        progress_state['percent'] = float(percent_str)\\n                    except:\\n                        pass\\n                elif d['status'] == 'finished':\\n                    progress_state['downloading'] = False\\n\\n            # Background task to update progress\\n            async def update_progress_loop():\\n                last_percent = -1\\n                while progress_state['downloading']:\\n                    current_percent = progress_state['percent']\\n                    # Only update if changed by at least 20% to reduce overhead\\n                    if abs(current_percent - last_percent) >= 20:\\n                        try:\\n                            await progress_callback(current_percent)\\n                            last_percent = current_percent\\n                        except Exception as e:\\n                            logger.debug(f\"Progress callback error: {e}\")\\n                    await asyncio.sleep(0.5)  # Check every 0.5 seconds\\n\\n            # Start progress updater if callback provided\\n            progress_task = None\\n            if progress_callback:\\n                progress_task = asyncio.create_task(update_progress_loop())\\n\\n            # Get ffmpeg path from imageio-ffmpeg\\n            ffmpeg_path = imageio_ffmpeg.get_ffmpeg_exe()\\n\\n            ydl_opts = {\\n                'format': 'bestaudio/best',\\n                'outtmpl': f'{self.temp_dir}/%(id)s_audio.%(ext)s',\\n                'quiet': True,\\n                'no_warnings': True,\\n                'ffmpeg_location': ffmpeg_path,\\n                'postprocessors': [{\\n                    'key': 'FFmpegExtractAudio',\\n                    'preferredcodec': 'mp3',\\n                    'preferredquality': '192',\\n                }],\\n                'progress_hooks': [progress_hook],\\n            }\\n\\n            logger.info(f\"Downloading YouTube audio\")\\n\\n            # Run download in executor\\n            loop = asyncio.get_event_loop()\\n            video_id = await loop.run_in_executor(\\n                None,\\n                lambda: self._download_with_ydl(url, ydl_opts)\\n            )\\n\\n            # Mark download as complete and wait for progress task\\n            progress_state['downloading'] = False\\n            if progress_task:\\n                try:\\n                    await asyncio.wait_for(progress_task, timeout=1.0)\\n                except asyncio.TimeoutError:\\n                    progress_task.cancel()\\n\\n            # Find the downloaded file\\n            expected_filename = f\"{self.temp_dir}/{video_id}_audio.mp3\"\\n            if os.path.exists(expected_filename):\\n                return expected_filename\\n\\n            # Fallback: look for any file with this video_id and .mp3\\n            for file in os.listdir(self.temp_dir):\\n                if video_id in file and file.endswith('.mp3'):\\n                    return f\"{self.temp_dir}/{file}\"\\n\\n            raise Exception(f\"Downloaded audio file not found for video {video_id}\")\\n\\n        except Exception as e:\\n            logger.error(f\"YouTube audio error: {e}\")\\n            raise\\n\\n    def _download_with_ydl(self, url: str, ydl_opts: dict) -> str:\\n        \"\"\"Helper to download synchronously and return video ID.\"\"\"\\n        with yt_dlp.YoutubeDL(ydl_opts) as ydl:\\n            # Get info first to know video ID\\n            info = ydl.extract_info(url, download=False)\\n            video_id = info.get('id', 'youtube')\\n\\n            # Then download\\n            ydl.download([url])\\n\\n            return video_id"
                                    },
                                    {
                                        "type": "file",
                                        "name": "info_extractor.py",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\downloader\\youtube\\info_extractor.py",
                                        "size_bytes": 7010,
                                        "content": "import yt_dlp\\nimport logging\\nimport asyncio\\nfrom typing import Dict\\n\\nlogger = logging.getLogger(__name__)\\n\\n\\nclass YouTubeInfoExtractor:\\n    \"\"\"Extract video information from YouTube.\"\"\"\\n\\n    def __init__(self, max_file_size: int = 50 * 1024 * 1024, is_premium: bool = False):\\n        self.max_file_size = max_file_size\\n        self.is_premium = is_premium\\n\\n    async def get_video_info(self, url: str) -> Dict:\\n        \"\"\"Get YouTube video info using yt-dlp.\"\"\"\\n        try:\\n            ydl_opts = {\\n                'quiet': True,\\n                'no_warnings': True,\\n                'extract_flat': False,\\n            }\\n\\n            # Run in executor to avoid blocking\\n            loop = asyncio.get_event_loop()\\n            info = await loop.run_in_executor(\\n                None,\\n                lambda: self._extract_info(url, ydl_opts)\\n            )\\n\\n            # Extract available formats/qualities with size estimation\\n            quality_info = {}  # {height: {'video_size': bytes, 'audio_size': bytes}}\\n\\n            if 'formats' in info:\\n                # First, find the best audio size\\n                best_audio_size = 0\\n                for fmt in info['formats']:\\n                    if fmt.get('acodec') != 'none' and fmt.get('vcodec') == 'none':\\n                        # This is an audio-only format\\n                        filesize = fmt.get('filesize') or fmt.get('filesize_approx')\\n                        if filesize and filesize > best_audio_size:\\n                            best_audio_size = filesize\\n\\n                # If no audio size found, estimate it\\n                if best_audio_size == 0:\\n                    duration = info.get('duration', 0)\\n                    minutes = duration / 60 if duration else 5\\n                    best_audio_size = int(minutes * 3 * 1024 * 1024)  # 3MB per minute\\n\\n                logger.info(f\"Audio stream size: {best_audio_size / (1024 * 1024):.1f}MB\")\\n\\n                # Now get video sizes\\n                for fmt in info['formats']:\\n                    height = fmt.get('height')\\n\\n                    # Only consider video formats (may not have audio)\\n                    if fmt.get('vcodec') != 'none' and height:\\n                        # Common qualities\\n                        if height in [144, 240, 360, 480, 720, 1080, 1440, 2160]:\\n                            video_size = fmt.get('filesize') or fmt.get('filesize_approx')\\n\\n                            if height not in quality_info:\\n                                quality_info[height] = {'video_size': video_size, 'audio_size': best_audio_size}\\n                            elif video_size is not None:\\n                                # Keep track of smallest video size for each quality\\n                                existing = quality_info[height]['video_size']\\n                                if existing is None or video_size < existing:\\n                                    quality_info[height] = {'video_size': video_size, 'audio_size': best_audio_size}\\n\\n            # Get duration for estimation\\n            duration = info.get('duration', 0)\\n\\n            # Calculate sizes for all qualities\\n            qualities_with_size = []\\n\\n            for height, size_info in quality_info.items():\\n                video_size = size_info['video_size']\\n                audio_size = size_info['audio_size']\\n\\n                # Calculate total size (video + audio)\\n                if video_size is None:\\n                    estimated_video_size = self._estimate_file_size(height, duration)\\n                    total_size = estimated_video_size + audio_size\\n\\n                    # Premium: show all, Regular: filter by size\\n                    if self.is_premium or total_size < self.max_file_size:\\n                        size_mb = total_size / (1024 * 1024)\\n                        qualities_with_size.append((height, total_size, f\"~{size_mb:.1f} MB\", True))\\n                else:\\n                    total_size = video_size + audio_size\\n\\n                    # Premium: show all, Regular: filter by size\\n                    if self.is_premium or total_size < self.max_file_size:\\n                        size_mb = total_size / (1024 * 1024)\\n                        qualities_with_size.append((height, total_size, f\"{size_mb:.1f} MB\", False))\\n\\n            # Sort by quality (high to low)\\n            qualities_with_size.sort(key=lambda x: x[0], reverse=True)\\n\\n            # Calculate audio-only size\\n            audio_only_size = best_audio_size\\n            audio_only_size_mb = audio_only_size / (1024 * 1024)\\n            audio_under_limit = self.is_premium or audio_only_size < self.max_file_size\\n\\n            mode = \"Premium\" if self.is_premium else f\"Regular (<{self.max_file_size / (1024 * 1024):.0f}MB)\"\\n            logger.info(f\"{mode}: {len(qualities_with_size)} qualities available\")\\n\\n            return {\\n                'title': info.get('title', 'YouTube Video')[:100],\\n                'author': info.get('uploader', 'Unknown'),\\n                'duration': self._format_duration(info.get('duration', 0)),\\n                'qualities_with_size': qualities_with_size,  # [(height, size_bytes, size_str, estimated)]\\n                'audio_size': audio_only_size,\\n                'audio_size_str': f\"{audio_only_size_mb:.1f} MB\",\\n                'audio_under_limit': audio_under_limit,\\n                'video_id': info.get('id', 'unknown'),\\n                'thumbnail': info.get('thumbnail', None)\\n            }\\n        except Exception as e:\\n            logger.error(f\"YouTube info error: {e}\")\\n            raise\\n\\n    def _extract_info(self, url: str, ydl_opts: dict) -> dict:\\n        \"\"\"Helper to extract info synchronously.\"\"\"\\n        with yt_dlp.YoutubeDL(ydl_opts) as ydl:\\n            return ydl.extract_info(url, download=False)\\n\\n    def _format_duration(self, seconds: int) -> str:\\n        \"\"\"Format seconds to readable time.\"\"\"\\n        if not seconds:\\n            return 'Unknown'\\n\\n        hours = seconds // 3600\\n        minutes = (seconds % 3600) // 60\\n        secs = seconds % 60\\n\\n        if hours > 0:\\n            return f\"{hours}:{minutes:02d}:{secs:02d}\"\\n        return f\"{minutes}:{secs:02d}\"\\n\\n    def _estimate_file_size(self, height: int, duration: int) -> int:\\n        \"\"\"Estimate VIDEO ONLY file size based on quality and duration.\"\"\"\\n        if duration == 0:\\n            duration = 300  # Assume 5 minutes if unknown\\n\\n        minutes = duration / 60\\n\\n        # Conservative estimates for VIDEO ONLY (audio added separately)\\n        video_mb_per_minute = {\\n            144: 1,\\n            240: 2,\\n            360: 5,\\n            480: 8,\\n            720: 15,\\n            1080: 25,\\n            1440: 40,\\n            2160: 60\\n        }\\n\\n        mb_per_min = video_mb_per_minute.get(height, 5)\\n        estimated_mb = mb_per_min * minutes\\n\\n        return int(estimated_mb * 1024 * 1024)  # Convert to bytes"
                                    },
                                    {
                                        "type": "file",
                                        "name": "video_downloader.py",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\downloader\\youtube\\video_downloader.py",
                                        "size_bytes": 4527,
                                        "content": "import os\\nimport logging\\nimport asyncio\\nimport yt_dlp\\nimport imageio_ffmpeg\\nfrom typing import Optional, Callable\\n\\nlogger = logging.getLogger(__name__)\\n\\n\\nclass YouTubeVideoDownloader:\\n    \"\"\"Download YouTube videos.\"\"\"\\n\\n    def __init__(self, temp_dir: str = \"temp\"):\\n        self.temp_dir = temp_dir\\n        os.makedirs(temp_dir, exist_ok=True)\\n\\n    async def download(self, url: str, quality: int = 360, progress_callback: Optional[Callable] = None) -> str:\\n        \"\"\"Download YouTube video using yt-dlp with progress tracking.\"\"\"\\n        try:\\n            # Shared progress state between threads\\n            progress_state = {'percent': 0, 'downloading': True}\\n\\n            # Progress hook runs in the download thread\\n            def progress_hook(d):\\n                if d['status'] == 'downloading':\\n                    percent_str = d.get('_percent_str', '0%').strip('%')\\n                    try:\\n                        progress_state['percent'] = float(percent_str)\\n                    except:\\n                        pass\\n                elif d['status'] == 'finished':\\n                    progress_state['downloading'] = False\\n\\n            # Background task to update progress\\n            async def update_progress_loop():\\n                last_percent = -1\\n                while progress_state['downloading']:\\n                    current_percent = progress_state['percent']\\n                    # Only update if changed by at least 20% to reduce overhead\\n                    if abs(current_percent - last_percent) >= 20:\\n                        try:\\n                            await progress_callback(current_percent)\\n                            last_percent = current_percent\\n                        except Exception as e:\\n                            logger.debug(f\"Progress callback error: {e}\")\\n                    await asyncio.sleep(0.5)  # Check every 0.5 seconds\\n\\n            # Start progress updater if callback provided\\n            progress_task = None\\n            if progress_callback:\\n                progress_task = asyncio.create_task(update_progress_loop())\\n\\n            # Get ffmpeg path from imageio-ffmpeg\\n            ffmpeg_path = imageio_ffmpeg.get_ffmpeg_exe()\\n\\n            # Format selector - get best video up to quality + best audio\\n            format_selector = f'bestvideo[height<={quality}]+bestaudio/best[height<={quality}]/best'\\n\\n            ydl_opts = {\\n                'format': format_selector,\\n                'outtmpl': f'{self.temp_dir}/%(id)s_{quality}p.%(ext)s',\\n                'quiet': True,\\n                'no_warnings': True,\\n                'merge_output_format': 'mp4',\\n                'ffmpeg_location': ffmpeg_path,\\n                'progress_hooks': [progress_hook],\\n            }\\n\\n            logger.info(f\"Downloading YouTube video at {quality}p\")\\n\\n            # Run download in executor\\n            loop = asyncio.get_event_loop()\\n            video_id = await loop.run_in_executor(\\n                None,\\n                lambda: self._download_with_ydl(url, ydl_opts)\\n            )\\n\\n            # Mark download as complete and wait for progress task\\n            progress_state['downloading'] = False\\n            if progress_task:\\n                try:\\n                    await asyncio.wait_for(progress_task, timeout=1.0)\\n                except asyncio.TimeoutError:\\n                    progress_task.cancel()\\n\\n            # Find the downloaded file\\n            expected_filename = f\"{self.temp_dir}/{video_id}_{quality}p.mp4\"\\n            if os.path.exists(expected_filename):\\n                return expected_filename\\n\\n            # Fallback: look for any file with this video_id\\n            for file in os.listdir(self.temp_dir):\\n                if video_id in file and file.endswith('.mp4'):\\n                    return f\"{self.temp_dir}/{file}\"\\n\\n            raise Exception(f\"Downloaded file not found for video {video_id}\")\\n\\n        except Exception as e:\\n            logger.error(f\"YouTube download error: {e}\")\\n            raise\\n\\n    def _download_with_ydl(self, url: str, ydl_opts: dict) -> str:\\n        \"\"\"Helper to download synchronously and return video ID.\"\"\"\\n        with yt_dlp.YoutubeDL(ydl_opts) as ydl:\\n            # Get info first to know video ID\\n            info = ydl.extract_info(url, download=False)\\n            video_id = info.get('id', 'youtube')\\n\\n            # Then download\\n            ydl.download([url])\\n\\n            return video_id"
                                    },
                                    {
                                        "type": "file",
                                        "name": "__init__.py",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\downloader\\youtube\\__init__.py",
                                        "size_bytes": 1366,
                                        "content": "import os\\nimport logging\\nfrom .info_extractor import YouTubeInfoExtractor\\nfrom .video_downloader import YouTubeVideoDownloader\\nfrom .audio_downloader import YouTubeAudioDownloader\\n\\nlogger = logging.getLogger(__name__)\\n\\n\\nclass YouTubeDownloader:\\n    \"\"\"Facade that combines all YouTube downloader components.\"\"\"\\n\\n    def __init__(self, temp_dir: str = \"temp\", max_file_size: int = 50 * 1024 * 1024, is_premium: bool = False):\\n        self.temp_dir = temp_dir\\n        self.max_file_size = max_file_size\\n        self.is_premium = is_premium\\n        os.makedirs(temp_dir, exist_ok=True)\\n        self.info_extractor = YouTubeInfoExtractor(max_file_size, is_premium)\\n        self.video_downloader = YouTubeVideoDownloader(temp_dir)\\n        self.audio_downloader = YouTubeAudioDownloader(temp_dir)\\n\\n    async def get_video_info(self, url: str):\\n        \"\"\"Get YouTube video info.\"\"\"\\n        return await self.info_extractor.get_video_info(url)\\n\\n    async def download_video(self, url: str, quality: int = 360, progress_callback=None):\\n        \"\"\"Download YouTube video.\"\"\"\\n        return await self.video_downloader.download(url, quality, progress_callback)\\n\\n    async def download_audio(self, url: str, progress_callback=None):\\n        \"\"\"Download YouTube audio.\"\"\"\\n        return await self.audio_downloader.download(url, progress_callback)"
                                    },
                                    {
                                        "type": "directory",
                                        "name": "__pycache__",
                                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\downloader\\youtube\\__pycache__",
                                        "children": []
                                    }
                                ]
                            },
                            {
                                "type": "file",
                                "name": "__init__.py",
                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\downloader\\__init__.py",
                                "size_bytes": 131,
                                "content": "from .youtube import YouTubeDownloader\\nfrom .tiktok import TikTokDownloader\\n\\n__all__ = ['YouTubeDownloader', 'TikTokDownloader']"
                            },
                            {
                                "type": "directory",
                                "name": "__pycache__",
                                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\downloader\\__pycache__",
                                "children": []
                            }
                        ]
                    },
                    {
                        "type": "directory",
                        "name": "__pycache__",
                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\app\\__pycache__",
                        "children": []
                    }
                ]
            },
            {
                "type": "file",
                "name": "dump.py",
                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\dump.py",
                "size_bytes": 3437,
                "content": "import os\\nimport json\\nimport fnmatch\\nfrom datetime import datetime, UTC\\n\\nFORCED_IGNORES = {\".git\"}\\n\\n\\ndef load_gitignore(root_path):\\n    gitignore_path = os.path.join(root_path, \".gitignore\")\\n    patterns = []\\n\\n    if not os.path.exists(gitignore_path):\\n        return patterns\\n\\n    with open(gitignore_path, \"r\", encoding=\"utf-8\") as f:\\n        for line in f:\\n            line = line.strip()\\n            if not line or line.startswith(\"#\"):\\n                continue\\n            patterns.append(line)\\n\\n    return patterns\\n\\n\\ndef is_ignored(path, root_path, patterns):\\n    try:\\n        rel_path = os.path.relpath(path, root_path).replace(\"\\\\\", \"/\")\\n    except ValueError:\\n        return True  # ignore paths on different mounts / device paths\\n\\n    parts = rel_path.split(\"/\")\\n\\n    if parts[0] in FORCED_IGNORES:\\n        return True\\n\\n    for pattern in patterns:\\n        if pattern.endswith(\"/\") and rel_path.startswith(pattern.rstrip(\"/\")):\\n            return True\\n\\n        if fnmatch.fnmatch(rel_path, pattern):\\n            return True\\n\\n        if fnmatch.fnmatch(os.path.basename(rel_path), pattern):\\n            return True\\n\\n    return False\\n\\n\\n\\ndef is_text_file(file_path, blocksize=512):\\n    try:\\n        with open(file_path, \"rb\") as f:\\n            return b\"\\0\" not in f.read(blocksize)\\n    except Exception:\\n        return False\\n\\n\\ndef read_file_content(file_path):\\n    try:\\n        with open(file_path, \"r\", encoding=\"utf-8\") as f:\\n            return f.read().replace(\"\\n\", \"\\\\n\")\\n    except Exception:\\n        return None\\n\\n\\ndef scrape_directory(current_path, root_path, ignore_patterns):\\n    children = []\\n\\n    try:\\n        entries = os.listdir(current_path)\\n    except PermissionError:\\n        return children\\n\\n    for entry in entries:\\n        full_path = os.path.join(current_path, entry)\\n\\n        if is_ignored(full_path, root_path, ignore_patterns):\\n            continue\\n\\n        if os.path.isdir(full_path):\\n            children.append({\\n                \"type\": \"directory\",\\n                \"name\": entry,\\n                \"path\": full_path,\\n                \"children\": scrape_directory(full_path, root_path, ignore_patterns)\\n            })\\n\\n        elif os.path.isfile(full_path):\\n            if not is_text_file(full_path):\\n                continue\\n\\n            content = read_file_content(full_path)\\n            if content is None:\\n                continue\\n\\n            children.append({\\n                \"type\": \"file\",\\n                \"name\": entry,\\n                \"path\": full_path,\\n                \"size_bytes\": os.path.getsize(full_path),\\n                \"content\": content\\n            })\\n\\n    return children\\n\\n\\ndef scrape_project(root_path):\\n    ignore_patterns = load_gitignore(root_path)\\n\\n    return {\\n        \"root\": root_path,\\n        \"generated_at\": datetime.now(UTC).isoformat(),\\n        \"structure\": {\\n            \"type\": \"directory\",\\n            \"name\": os.path.basename(root_path),\\n            \"path\": root_path,\\n            \"children\": scrape_directory(root_path, root_path, ignore_patterns)\\n        }\\n    }\\n\\n\\nif __name__ == \"__main__\":\\n    ROOT_DIR = \"./\"\\n    result = scrape_project(os.path.abspath(ROOT_DIR))\\n\\n    with open(\"project_dump3.json\", \"w\", encoding=\"utf-8\") as f:\\n        json.dump(result, f, indent=4)\\n\\n    print(\"Done \u2192 .git ignored, .gitignore respected \u2714\")\\n"
            },
            {
                "type": "file",
                "name": "LICENSE",
                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\LICENSE",
                "size_bytes": 1095,
                "content": "MIT License\\n\\nCopyright (c) 2026 Denys Herasymchuk\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\nof this software and associated documentation files (the \"Software\"), to deal\\nin the Software without restriction, including without limitation the rights\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\ncopies of the Software, and to permit persons to whom the Software is\\nfurnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in all\\ncopies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\nSOFTWARE.\\n"
            },
            {
                "type": "directory",
                "name": "logs",
                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\logs",
                "children": [
                    {
                        "type": "file",
                        "name": ".gitkeep",
                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\logs\\.gitkeep",
                        "size_bytes": 0,
                        "content": ""
                    }
                ]
            },
            {
                "type": "file",
                "name": "README.md",
                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\README.md",
                "size_bytes": 305,
                "content": "# DAYN - Download All Your Needs.\\nYouTube/TikTok Downloader Bot\\n\\nA Telegram bot that downloads videos from YouTube and TikTok.\\n\\n## Setup\\n1. Clone repo\\n2. Install: `pip install -r requirements.txt`\\n3. Get bot token from @BotFather\\n4. Create `.env` with your token\\n5. Run: `python -m app.bot.main`"
            },
            {
                "type": "file",
                "name": "requirements.txt",
                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\requirements.txt",
                "size_bytes": 164,
                "content": "aiogram>=3.24.0\\naiohttp>=3.13.3\\naiofiles>=25.1.0\\nmagic-filter>=1.0.12\\npytube==15.0.0\\nyt-dlp==2024.11.11\\npython-dotenv==1.0.0\\nrequests==2.31.0\\nimageio-ffmpeg"
            },
            {
                "type": "file",
                "name": "run.py",
                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\run.py",
                "size_bytes": 252,
                "content": "import sys\\nimport os\\nimport asyncio\\n\\nsys.path.insert(0, os.path.dirname(__file__))\\n\\nfrom app.bot.main import main\\n\\nif __name__ == \"__main__\":\\n    try:\\n        asyncio.run(main())\\n    except KeyboardInterrupt:\\n        print(\"\\nBot stopped.\")"
            },
            {
                "type": "directory",
                "name": "temp",
                "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\temp",
                "children": [
                    {
                        "type": "file",
                        "name": ".gitkeep",
                        "path": "C:\\Users\\HomePC\\Desktop\\works\\Telegram\\DAYN\\temp\\.gitkeep",
                        "size_bytes": 0,
                        "content": ""
                    }
                ]
            }
        ]
    }
}